<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-25T23:03:44-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Arktos kai Mennos</title><subtitle>Arun Vijayshankar&apos;s blog</subtitle><entry><title type="html">Implementing TCP in Rust</title><link href="http://localhost:4000/archive/programming,/rust,/networking/implementing-tcp-in-rust/" rel="alternate" type="text/html" title="Implementing TCP in Rust" /><published>2022-03-25T15:19:50-07:00</published><updated>2022-03-25T15:19:50-07:00</updated><id>http://localhost:4000/archive/programming,/rust,/networking/implementing-tcp-in-rust</id><content type="html" xml:base="http://localhost:4000/archive/programming,/rust,/networking/implementing-tcp-in-rust/">&lt;p&gt;One good thing about Twitter&lt;sup&gt;TM&lt;/sup&gt; is that once in a while I come across a tweet that voices out load the exact thing I was looking for. In this instance, I found this &lt;a href=&quot;https://twitter.com/b0rk/status/1505597582227165194&quot;&gt;tweet&lt;/a&gt; from &lt;a href=&quot;https://twitter.com/b0rk&quot;&gt;@b0rk&lt;/a&gt;, looking for networking courses. There were a lot of good suggestions, but this one caught my eye: &lt;a href=&quot;https://www.youtube.com/playlist?list=PLqbS7AVVErFivDY3iKAQk3_VAm8SXwt1X&quot;&gt;Implementing TCP&lt;/a&gt;, by &lt;a href=&quot;https://twitter.com/jonhoo&quot;&gt;@jonhoo&lt;/a&gt;. It is an implementation of TCP using Rust. It drew my eye immediately as learning Rust has been on my mind for a while now. Now, I do not know the first thing about Rust, and not very much more about networking, but I have found that I learn best by doing, so I drove right into it. Jon mentions RFC 1180 as a good tutorial to TCP/IP which I started reading  in parallel to the video series. I’m about 45 minutes into Part 1, and there are already a bunch of concepts with which I am completely unfamiliar. Nevertheless, just by following along, I was able to write a “virtual” NIC in rust. The only thing it does is read an IP packet as a bunch of bytes. Still, pretty cool. It wasn’t without hicups though. The setcap command did not work until I provided the entire path to the compiled binary, and for some reason $CARGO_TARGET_DIR, which I assumed was set during the setup, was not really set to anything. But barring these minor setbacks, the code compiled and ran pretty well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post3/ip_packet_rcvd_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first new rust concept i hit upon in the video was cargo. Cargo is the build and packaging system of Rust. I learned that it downloads the necessary libraries and builds your code. You list your projects dependencies (packages of code, called Crates) in the .toml file, and Cargo will download and link them for you. You can use cargo to build your code using “cargo build –release” and it will build and create your binaries in a separate folder. There are a bunch of options you can specify in the build command like ‘r’ to build your code, and then run it, or ‘b’ to only compile your code and build the binary.&lt;/p&gt;

&lt;p&gt;The tutorial introduced TUN/TAP next. This is a really cool kernel module that provides packet transmission and reception for User space programs. If I understand correctly, it creates a virtual network adapter to whom the kernel forwards packets from a user space program, and whose packets the kernel sends to the user space program. There is already a Rust crate for Tun/Tap bindings which is used in the tutorial. It’s a really cool module, and I’m sure I’ll be using it a lot in my networking adventures in the future. The actual syntax is very similar to C and Jon quickly covered the actual code by following the tun_tap docs closely.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
use std::io;

fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; {
	let nic = tun_tap::Iface::new(&quot;tun0&quot;, tun_tap::Mode::Tun)?;
	let mut buf = [0u8; 1504];
	let nbytes = nic.recv(&amp;amp;mut buf[..])?;
	eprintln!(&quot;read {} bytes: {:x?}&quot;, nbytes, &amp;amp;buf[..nbytes]);
	Ok(())
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A new thing in Rust is the syntax to use library functions. For example, to user a function called “some_function()” that is part of “some_library”, you would write: some_library::some_function(). A few other new things are “match”, OK(), Err(), and the “-&amp;gt;” and “=&amp;gt;” operators, but I will dive deeper into them as I move forward.&lt;/p&gt;

&lt;p&gt;To use TUN/TAP, we need CAP_NET_ADMIN privileges which is confirgured with the setcap command: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo setcap cap_net_admin=eip &amp;lt;path_to_target&amp;gt;&lt;/code&gt;. The tutorial uses $CARGO_TARGET_DIR in the path, but for some reason this did not work for me. I am not really sure if I have to set this variable myself, or if it gets set by cargo. In any case I was able to get around this by simply providing the relative path to the target. Finally, we compiled the code and ran it. Now when you run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip addr&lt;/code&gt;, you can see tun0 show up in your list of network devices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post3/tun0_offline.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As of now, tun0 is not really doing anything. To configure it to listen for IP packets we have to run the following commands:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
sudo ip addr add &amp;lt;some IP address&amp;gt; dev tun0

sudo ip link set up dev tun0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;ip addr add &amp;lt;static IP address&amp;gt; dev &amp;lt;device name&amp;gt;&quot;&lt;/code&gt; adds an ip address to the newly created network device tun0, and once that’s done, we bring tun0 online with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;ip link set up dev &amp;lt;device name&amp;gt;&quot;&lt;/code&gt;. tun0 will now listen for IP packets and the code will display the bytes in the packet that tun0 received.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post3/tun0_online.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To simplify the whole process, all the individual commands were wrapped up in a shell file:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;lt;#!/bin/bash
cargo b --release
sudo setcap cap_net_admin=eip &amp;lt;path to binary&amp;gt;
&amp;lt;path to binary&amp;gt; &amp;amp;
pid=$!
sudo ip addr add 192.168.0.1/24 dev tun0
sudo ip link set up dev tun0
trap &quot;kill $pid&quot; INT TERM
wait $pid

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and anytime we want trust to listen for IP packets sent to tun0, we can run the .sh file to compile any changes to the code, set cap_net_admin, run the program, and bring tun0 online.&lt;/p&gt;

&lt;p&gt;So now we can bring tun0 online and listen for packets, but the program will stop running once tun0 receives an IP packet. To keep tun0 listening indefinitely, we put it in a loop. Loop is a rust functionality that let’s you run an infinite loop. Just put your code in a block like so&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
loop {

	# code goes here

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we can ping the IP address we set earlier, and the component bytes will be displayed consecutively. However, these bytes are not really readable to most of us, I would imagine. To make better sense of the data, a rust crate called etherparse can be used to parse the hex data and extract useful information from them. We choose to pull source IP, destination IP, payload length, and IP protocol.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
match etherparse::Ipv4HeaderSlice::from_slice(&amp;amp;buf[4..nbytes]) {
	Ok(p) =&amp;gt; {
		let src = p.source_addr();
		let dst = p.destination_addr();
		let protocol = p.protocol();
		eprintln!(
			&quot;{} -&amp;gt; {} {}b of protocol {}&quot;,
			src,
			dst,
			p.payload_len(),
			protocol
		);
	},
	Err(e) =&amp;gt; {
		eprintln!(&quot;ignoring weird packet {:?}&quot;, e);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When we run the wrapper, we see a nicely formatted, more informational strings:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post3/formatted_packets_ping.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that packets were sent to 192.168.0.2 from 192.168.0.1 with IP protocol 1, which is ICMP which is what ping uses. We can also use netcap to try and connect to the IP address (at any port) to see if it is reflected correctly:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post3/formatted_packet_tcp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that 40 bytes are received of protocol 6, which is TCP.&lt;/p&gt;

&lt;p&gt;This brings us to the end of the first 45 minutes of the tutorial. I will cover the rest of the tutorial in roughly one hour chunks, I think. Along with actually coding and ironing out issues, it takes me around an hour or so to get through 45 minutes of video, so it seems like a good duration. The tutorial is 13 hours in total, and I expect to complete it in a month or so. Ideally, I would like to finish it a lot sooner, but needs must, so 45 minutes at a time it will have to be.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming," /><category term="rust," /><category term="networking" /><category term="programming" /><category term="rust" /><category term="networking" /><summary type="html">One good thing about TwitterTM is that once in a while I come across a tweet that voices out load the exact thing I was looking for. In this instance, I found this tweet from @b0rk, looking for networking courses. There were a lot of good suggestions, but this one caught my eye: Implementing TCP, by @jonhoo. It is an implementation of TCP using Rust. It drew my eye immediately as learning Rust has been on my mind for a while now. Now, I do not know the first thing about Rust, and not very much more about networking, but I have found that I learn best by doing, so I drove right into it. Jon mentions RFC 1180 as a good tutorial to TCP/IP which I started reading in parallel to the video series. I’m about 45 minutes into Part 1, and there are already a bunch of concepts with which I am completely unfamiliar. Nevertheless, just by following along, I was able to write a “virtual” NIC in rust. The only thing it does is read an IP packet as a bunch of bytes. Still, pretty cool. It wasn’t without hicups though. The setcap command did not work until I provided the entire path to the compiled binary, and for some reason $CARGO_TARGET_DIR, which I assumed was set during the setup, was not really set to anything. But barring these minor setbacks, the code compiled and ran pretty well.</summary></entry><entry><title type="html">Password protection in python scripts</title><link href="http://localhost:4000/archive/programming/password-protection-in-python-scripts/" rel="alternate" type="text/html" title="Password protection in python scripts" /><published>2022-03-08T19:50:00-08:00</published><updated>2022-03-08T19:50:00-08:00</updated><id>http://localhost:4000/archive/programming/password-protection-in-python-scripts</id><content type="html" xml:base="http://localhost:4000/archive/programming/password-protection-in-python-scripts/">&lt;p&gt;I came across an interesting problem recently. I was running a python script that would periodically update a remote database. It would connect to the database with a shared login credential and update a table. The script would run locally on multiple machines. Initially, the hashed db password was stored in the script, and extracted before being used to connect to the database.&lt;/p&gt;

&lt;p&gt;It was not too long before I realized that anyone with access to the script can straight up read the password without so much as a how do you do. I looked up password protection on the internet, and there are some good approaches out there, like using hashing with hashlib, storing the password in env values, or using Keyring to store and fetch the password. You can find a good tutorial on using them &lt;a href=&quot;https://martinheinz.dev/blog/59&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;However, these approaches face the same issue. Anyone with access to the machine the script is running on, can recover the password quite easily. I think only some form of secure handshake/authentication protocol can provide user authentication without storing the password in the script. The problem is, I do not know the first thing about setting up such a system. Especially with a DBMS with which I am unfamiliar. Also, I’m pretty sure the shared login is pretty much an immutable object (pun intended), and I cannot avoid using it. So I thought about it some more, and it occurred to me, that the only reason to keep the password in the script in the first place was because it used a connect_to_db module in the same script to connect to the database.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/db_conn_mod.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I realized that if I moved the entire connection module to a different file, and imported that file as a library in my script, my script would still have the db connection, but would not need the password in the script in any form. I could then use Keyring in the special connection library to retrieve a password that I store on the system separately, again using Keyring. But this just moves the problem to a different python file. To ensure that the password cannot be extracted from the connection lib file either, I hit upon the idea of compiling the lib file, and including only the byte file along with the main script. And that did it! The script works, and has at least somewhat better security than earlier.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/conn.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, this is still not very secure. It is very easy to de-compile the pyc file and extract the password from it. Still, some security is better than no security.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="programming" /><summary type="html">I came across an interesting problem recently. I was running a python script that would periodically update a remote database. It would connect to the database with a shared login credential and update a table. The script would run locally on multiple machines. Initially, the hashed db password was stored in the script, and extracted before being used to connect to the database.</summary></entry><entry><title type="html">My first “official” programming project</title><link href="http://localhost:4000/archive/programming/my-first-official-programming-project/" rel="alternate" type="text/html" title="My first “official” programming project" /><published>2022-03-06T15:30:05-08:00</published><updated>2022-03-06T15:30:05-08:00</updated><id>http://localhost:4000/archive/programming/my-first-official-programming-project</id><content type="html" xml:base="http://localhost:4000/archive/programming/my-first-official-programming-project/">&lt;p&gt;Today I wrote my first ever code for a work project. Well, technically it’s the second time, but the first time doesn’t count as I was just changing variable names in someone else’s library. First, some background: over the past year, I have been steadily working toward transitioning from software tester to software dev. I decided to go for the self-learning model as it best suited me as a full time employee. I started learning the CS fundamentals of data structures and algorithms, and for actual development, I mostly used python, as it seemed friendly to me. Also because I like snakes (I know, I know, it’s a Monty Python reference, not a herpetological one). I also wrote a few things in C, because I love C. In parallel to theory, I started a project to get some hands on experience. I wanted to work on something I am actually invested in, so I started writing a password management system. I managed to get the backend all squared away, using redis for the backend, and python for middleware. The front end is still in the backlog, as I’ve just started learning frontend development. Interested parties can find it here.&lt;/p&gt;

&lt;p&gt;Working on side projects is a lot of fun, but I really wanted to get my hands dirty by working on an officially sanctioned project at work. As mentioned previously, I am a software tester. Testers do not usually get to write code. But as has been frequently been pointed out to me, there are always opportunities to work on interesting things in my team, for those who ask for it. In the past, I have been reticent to ask for something I wanted to work on, because, “gasp! what if they actually give it to me?? And I can’t do it!? The horror!”. Now, however, I was tired of letting fear hold me back from doing the things I want. I’m tired of standing at the sidelines watching people play. I decided to jump in and ask for a coding project. My manager said he’d see what he could do. A few weeks later, he asked me to think of a way to automate a rather tiresome task my team had been doing manually for the past few months. I came up with an idea and ran it by him, and he pulled in a few more people, and before I knew it, I was adding it as a feature to a bigger project. The project is implemented in python, and it uses a DBMS that I haven’t used before (i.e., anything other than redis), but learning it has been a lot of fun. I wrote two modules today, and after a few hiccups, I got them working!&lt;/p&gt;

&lt;p&gt;There are a few more challenges to overcome before the feature can be pulled in, but I’m quite optimistic about it. If it is implemented in the coming weeks, not only will it be useful to others in my team, but it will be the first feature that I developed!&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="programming" /><summary type="html">Today I wrote my first ever code for a work project. Well, technically it’s the second time, but the first time doesn’t count as I was just changing variable names in someone else’s library. First, some background: over the past year, I have been steadily working toward transitioning from software tester to software dev. I decided to go for the self-learning model as it best suited me as a full time employee. I started learning the CS fundamentals of data structures and algorithms, and for actual development, I mostly used python, as it seemed friendly to me. Also because I like snakes (I know, I know, it’s a Monty Python reference, not a herpetological one). I also wrote a few things in C, because I love C. In parallel to theory, I started a project to get some hands on experience. I wanted to work on something I am actually invested in, so I started writing a password management system. I managed to get the backend all squared away, using redis for the backend, and python for middleware. The front end is still in the backlog, as I’ve just started learning frontend development. Interested parties can find it here.</summary></entry></feed>
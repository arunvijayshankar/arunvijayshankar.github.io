<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-28T13:53:54-08:00</updated><id>/feed.xml</id><title type="html">Arktos kai Mennos</title><subtitle>Arun Vijayshankar&apos;s blog</subtitle><entry><title type="html">Problem solving and mindfulness</title><link href="/archive/problem-solving-and-mindfulness/" rel="alternate" type="text/html" title="Problem solving and mindfulness" /><published>2023-11-28T00:00:00-08:00</published><updated>2023-11-28T00:00:00-08:00</updated><id>/archive/problem-solving-and-mindfulness</id><content type="html" xml:base="/archive/problem-solving-and-mindfulness/">&lt;p&gt;I wanted to write a little something about a change I noticed in the way I usually respond when I find myself unable to find a solution to a problem. A few weeks ago I was trying to solve this problem&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post16/prob.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After working on it off and on for a few days, I hit upon the key idea that solved it just as I was falling asleep.&lt;/p&gt;

&lt;p&gt;I don’t think it’s a very tough problem, however I had quite some trouble cracking it. Luckily there was a hint, and I was able to make some progress, but I got stuck soon after. I started to feel a familiar sense of frustration and a strong desire to give up and look the solution up. In the not so very distant past, I would have succumbed and looked the solution up, and then immediately felt insecure about it.&lt;/p&gt;

&lt;p&gt;This time, I told myself that I should put it away for the day and give it another shot later. I started working on it again the next day, when a different approach suggested itself and I was able to go a little further. This surprised me because my usual practice is to try the same thing over and over again and then get frustrated when it doesn’t work. Eventually, when the intrusive thoughts, “It’s hopeless”, “I told you, you’re horrible at math”, “stop fooling yourself”, inevitably won, I would give up and be depressed for a while.&lt;/p&gt;

&lt;p&gt;Recently however, I am noticing that I have been able to avoid this mental road block. It’s not that the thoughts aren’t there, they are ever present, but I’ve been getting better at keeping at it even with the circling negativity. I have observed that if I acknowledge the negative thought (or just ignore it) and try again, more often than not, I find the solution to the problem, or I think of a different approach to finding it. It almost feels like the I had the answer all along, but I couldn’t find it because of all the cacophony in my head. But if I take a moment to relax, maybe do the 4x4 breaths technique, I find the way forward.&lt;/p&gt;

&lt;p&gt;Another factor is the complete lack of time pressure. I have no assignment deadlines, or timed exams where I have to solve problems in a finite amount of time. I’m doing this as a hobby, and I can take all the time I need. Without all the anxiety to finish in time, it’s a lot easier to think of alternative approaches to problem solving. Sure, sometimes I feel insecure about spending whole days to solve a relatively simple problem, but hey, instead of giving up and feeling sad about it, I’m finding answers and feeling a sense of joy and accomplishment.&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="mindfulness" /><summary type="html">I wanted to write a little something about a change I noticed in the way I usually respond when I find myself unable to find a solution to a problem. A few weeks ago I was trying to solve this problem</summary></entry><entry><title type="html">Powers of a permutation matrix - Part 3</title><link href="/archive/powers-of-permutation-matrices-pt3/" rel="alternate" type="text/html" title="Powers of a permutation matrix - Part 3" /><published>2023-11-22T00:00:00-08:00</published><updated>2023-11-22T00:00:00-08:00</updated><id>/archive/powers-of-permutation-matrices-pt3</id><content type="html" xml:base="/archive/powers-of-permutation-matrices-pt3/">&lt;p&gt;In &lt;a href=&quot;https://arunvijayshankar.github.io/archive/powers-of-permutation-matrices-pt2/&quot;&gt;Part 2&lt;/a&gt;, we saw how permutations consisting of simple cycles always return to their original configurations. Now let’s consider a permutation &lt;em&gt;p&lt;/em&gt;, consisting of &lt;em&gt;m&lt;/em&gt; number of cycles, with sizes &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;, k&lt;sub&gt;2&lt;/sub&gt;, … k&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;, such that&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post15/sum.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and no two cycles are of the same length. For such a permutation we have&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post15/pwr_prod.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;since any cycle will return to it’s original position at the &lt;em&gt;q&lt;/em&gt; times &lt;em&gt;k&lt;/em&gt;th application of &lt;em&gt;p&lt;/em&gt; (where &lt;em&gt;k&lt;/em&gt; is the length of the cycle), which means that all cycles in the permutation will return to their original positions when the permutation is applied&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post15/prod.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;times.&lt;/p&gt;

&lt;p&gt;But what if the cycles are not all of the cycles are of different lengths? In that case we only need to consider the unique lengths among the various cycle lengths. That is, if the permutation consists of one 2-cycle, three 5-cycles, two 3-cycles, and two 7-cycles, then the permutation will return to it’s initial configuration at the 2 x 5 x 7 x 3  = 210th application of the permutation. This is easy to see becuase if there are &lt;em&gt;l&lt;/em&gt; cycles of length &lt;em&gt;k&lt;/em&gt;, all of them will return to their starting configuration at every &lt;em&gt;k&lt;/em&gt;th application of the permutation. Once again I’m ignoring situations where one cycle is a of a length that is a multiple of another cycles length, since the other cycle will in any case return to it’s original position when the larger cycle returns to it’s original position. The thing it would impact is the smallest number &lt;em&gt;N&lt;/em&gt; such that &lt;em&gt;p&lt;sup&gt;N&lt;/sup&gt; = e&lt;/em&gt;. I’m not sure how to go about tackling that.&lt;/p&gt;

&lt;p&gt;One question remains - Can all permutations be represented as collections of cycles. To see why the answer is yes, consider that any permutation has at least one cycle. Let’s assume that a permutationhas m cycles, with fixed points being cycles of length 1. Now imagine that there are some elements in the set being permuted that do not belong to either of the m cycles. If we now apply the permutation to just these points, then either they retain their positions, making them fixed points which is a contradiction, or they do move to different positions, implying that there is a cycle of size at least two, which is also a contradiction. This means that every permutation has to be composed of cycles.&lt;/p&gt;

&lt;p&gt;One last note - I posted about powers of permutations on reddit, and a user asked if anything can be said about &lt;em&gt;p&lt;sup&gt;n!&lt;/sup&gt;&lt;/em&gt; where &lt;em&gt;n&lt;/em&gt; is the number of elements being permuted. Since the lengths of the cycles that make up any permutation will always be lesser than or equal to the number of elements in the set, &lt;em&gt;n!&lt;/em&gt; will include all the cycle lengths in the product. So &lt;em&gt;p&lt;sup&gt;n!&lt;/sup&gt;&lt;/em&gt; will also be the identity. So there was a much simpler way to show that such a number exists. But it is not necessarily the &lt;em&gt;smallest&lt;/em&gt; number such that &lt;em&gt;p&lt;sup&gt;N&lt;/sup&gt;&lt;/em&gt; is the identity. I am fairly confident that the smallest number &lt;em&gt;N&lt;/em&gt; with this property is the least common multiple of &lt;em&gt;(n, n-1, n-2, …, 1)&lt;/em&gt; but I don’t know how to prove it.&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="linearalgebra" /><category term="permutations" /><summary type="html">In Part 2, we saw how permutations consisting of simple cycles always return to their original configurations. Now let’s consider a permutation p, consisting of m number of cycles, with sizes k1, k2, … km, such that</summary></entry><entry><title type="html">Order of the Power Set</title><link href="/archive/order-of-power-set/" rel="alternate" type="text/html" title="Order of the Power Set" /><published>2023-10-10T00:00:00-07:00</published><updated>2023-10-10T00:00:00-07:00</updated><id>/archive/order-of-power-set</id><content type="html" xml:base="/archive/order-of-power-set/">&lt;p&gt;Here are two ways to determine the number of elements in the Power set of a finite set of objects. The set of all subsets of a set is called a power set, and the number of all the elements in a given set is called its order. Consider the following set &lt;em&gt;S = {a, b, c}&lt;/em&gt;. The order of this set is 3, and its power set is &lt;em&gt;P(S) = {O, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, S}&lt;/em&gt;. Notice that the power set contains all subsets of &lt;em&gt;S&lt;/em&gt;, including &lt;em&gt;S&lt;/em&gt;, and the empty set &lt;em&gt;O&lt;/em&gt;. We can see that &lt;em&gt;P(S)&lt;/em&gt; has 8 elements, so its order is 8. If you carried out a similar exercize for a set &lt;em&gt;S’ = {a, b, c, d}&lt;/em&gt;, we will find that its order is 16. It looks like the order of a the power set of a set with &lt;em&gt;n&lt;/em&gt; elements is &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;We can show that this is actually true. Let’s prove it in two ways. First let’s use mathematical induction, which is intuitive and clean, but a little dry IMO. Next, let’s show that it is true by just counting the elements (kind of). This is a lot more fun, and it’s nice to see how a couple of things come together to solve the problem.&lt;/p&gt;

&lt;p&gt;But first let’s do induction. Notice that if a set &lt;em&gt;S&lt;/em&gt; is empty, it has &lt;em&gt;n = 0&lt;/em&gt; elements. The power set, &lt;em&gt;P(S)&lt;/em&gt;, then only has one element - the empty set (which is also the entire set &lt;em&gt;S&lt;/em&gt;). So the order of the power set is 1, and &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;0&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;1&lt;/em&gt;, so the base case is true. Now let’s assume that it is true for the power set of a set with &lt;em&gt;n&lt;/em&gt; elements. So the power set of a set with &lt;em&gt;n&lt;/em&gt; elements would have order &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;. Let’s denote the elements of the power sets as &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;1&lt;/em&gt;&lt;/sub&gt;, &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;2&lt;/em&gt;&lt;/sub&gt;, …, &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;m&lt;/em&gt;&lt;/sub&gt;, where &lt;em&gt;m&lt;/em&gt; = &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;. Now consider adding one more element to &lt;em&gt;S&lt;/em&gt;, bringing the number of elements contained by it to &lt;em&gt;n+1&lt;/em&gt;. Adding this additional element to &lt;em&gt;S&lt;/em&gt; creates a whole bunch of new subsets, and we have to determine how many new subsets are created and add it to &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;, to find the order of the new power set of &lt;em&gt;S&lt;/em&gt;. Notice that all the new subsets of &lt;em&gt;S&lt;/em&gt; can be created by adding the new element to each of the subsets of &lt;em&gt;S&lt;/em&gt; with &lt;em&gt;n&lt;/em&gt; elements.&lt;/p&gt;

&lt;p&gt;For example, if &lt;em&gt;S&lt;/em&gt; = &lt;em&gt;{a, b}&lt;/em&gt;, then &lt;em&gt;P(S)&lt;/em&gt; = &lt;em&gt;{O, {a}, {b}, S}&lt;/em&gt;. If we add a third element, &lt;em&gt;c&lt;/em&gt;, to this set, then we get the new subsets -&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/new_sets.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essentially, by adding an additional element to &lt;em&gt;S&lt;/em&gt;, we are adding one additional subset to every subset in power set of the original set. So we have two times as many elements in the power set of a set with &lt;em&gt;n+1&lt;/em&gt; elements, as in the power set of one with &lt;em&gt;n&lt;/em&gt; elements. That is, the order of the power set of a set with &lt;em&gt;n+1&lt;/em&gt; elements is &lt;em&gt;2&lt;/em&gt; x &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n+1&lt;/em&gt;&lt;/sup&gt;, and we are done.&lt;/p&gt;

&lt;p&gt;Now let’s do it the fun way. Notice that we can determine the number of subsets of a set with &lt;em&gt;n&lt;/em&gt; elements by counting the number of subsets with 0 elements (the empty set), the number of subsets with 1 element (these are called singletons, there are &lt;em&gt;n&lt;/em&gt; of them), with 2 elements and so on, up to the number of subsets with &lt;em&gt;n&lt;/em&gt; elements (there’s one such subset - the entire set), and then adding them all up. To do this, let’s find the number of subsets with &lt;em&gt;k&lt;/em&gt; elements. This is equivalent to the number of ways of choosing &lt;em&gt;k&lt;/em&gt; objects from a collection of &lt;em&gt;n&lt;/em&gt; objects. We know that this is&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/nCk_new.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we have to sum the number of subsets with &lt;em&gt;k&lt;/em&gt; elements from &lt;em&gt;k&lt;/em&gt; = &lt;em&gt;0&lt;/em&gt; to &lt;em&gt;k&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt;. That is, the order of the power set is&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/order.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;All that is left to do is to evaluate this sum. It looks a little intimidating, and trying to evaluate it by expanding the sum and adding all the terms will turn out to be quite an effort. So maybe there’s another way. Notice that the sum looks remarkably similar to the sum in the binomial theorem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/binom_thm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In fact if we set &lt;em&gt;x&lt;/em&gt; = &lt;em&gt;y&lt;/em&gt; = &lt;em&gt;1&lt;/em&gt; in the binomial theorem, the sum will be the same as the sum in our expression for the order of the power set,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/binom_mod.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/xplusy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;which means&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/final.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and we’re done!&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="counting" /><category term="settheory" /><summary type="html">Here are two ways to determine the number of elements in the Power set of a finite set of objects. The set of all subsets of a set is called a power set, and the number of all the elements in a given set is called its order. Consider the following set S = {a, b, c}. The order of this set is 3, and its power set is P(S) = {O, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, S}. Notice that the power set contains all subsets of S, including S, and the empty set O. We can see that P(S) has 8 elements, so its order is 8. If you carried out a similar exercize for a set S’ = {a, b, c, d}, we will find that its order is 16. It looks like the order of a the power set of a set with n elements is 2n.</summary></entry><entry><title type="html">Powers of a permutation matrix - Part 2</title><link href="/archive/powers-of-permutation-matrices-pt2/" rel="alternate" type="text/html" title="Powers of a permutation matrix - Part 2" /><published>2023-10-01T00:00:00-07:00</published><updated>2023-10-01T00:00:00-07:00</updated><id>/archive/powers-of-permutation-matrices-pt2</id><content type="html" xml:base="/archive/powers-of-permutation-matrices-pt2/">&lt;p&gt;In &lt;a href=&quot;https://arunvijayshankar.github.io/archive/powers-of-permutation-matrices-pt1/&quot;&gt;Part 1&lt;/a&gt;, we saw how every permutation has at least one cycle, and that the size of the cycle is the number of elements in the cycle. If we now consider a permutation that is one big cycle of all the elements in our set, then we can easily see that if we apply the same permutation &lt;em&gt;n&lt;/em&gt; times, &lt;em&gt;n&lt;/em&gt; being the number of elements in the set, all elements return to the positions with which they started out. So &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;e&lt;/em&gt; for such a permutation, where once again, &lt;em&gt;e&lt;/em&gt; is the identity.&lt;/p&gt;

&lt;p&gt;But what about permutations that are not just one cycle of all elements? What if the permutation consists of a combinations of cycles of different cycles and/or fixed points (elements that remain fixed in their positions upon application of a permutation are called fixed points). To explore this further, let us consider a couple of specific examples.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt; The permutation is one in which two elements in the set switch places, the rest are fixed points - In this case, there is one cycle of size two, and the rest are fixed points, so they are all in cycles of size one. So if we apply the permutation for a second time, both elements that switched places return to their original position, and the rest will have remained in the same position with which they started out. So if &lt;em&gt;p&lt;/em&gt; denotes this particular permutation, then &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 2 &lt;/li&gt;
	&lt;li&gt;The permutation consists of two cycles of size &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; respectively - Here, we immediately see that the first cycle with return to its starting arrangement after &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; applications of the permutation and the second cycle will return to its starting arrangement after &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; applications. To calculate how many applications of the permutation are needed for both cycles to return to the starting configuration, notice that either cycle will return to the start when the permutation is applied &lt;em&gt;mk&lt;/em&gt; times, where &lt;em&gt;m&lt;/em&gt; is a positive integer. So this means that if the permutation is applied &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; times, both cycles will have returned to their original positions (notice that if &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;qk&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; then both cycles will return to the starting positions after just &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; applications of the permutation). That is, &lt;em&gt;p&lt;sup&gt;k&lt;sub&gt;1&lt;/sub&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/sup&gt;&lt;/em&gt; = &lt;em&gt;e&lt;/em&gt;&lt;/li&gt; 
&lt;/ol&gt;

&lt;p&gt;Let’s stop here for now, and in Part 3 let’s explore permutations that are a little more complex, and finally try and nail down the answer for any generic permutation.&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="linearalgebra" /><category term="permutations" /><summary type="html">In Part 1, we saw how every permutation has at least one cycle, and that the size of the cycle is the number of elements in the cycle. If we now consider a permutation that is one big cycle of all the elements in our set, then we can easily see that if we apply the same permutation n times, n being the number of elements in the set, all elements return to the positions with which they started out. So pn = e for such a permutation, where once again, e is the identity.</summary></entry><entry><title type="html">Powers of a permutation matrix - Part 1</title><link href="/archive/powers-of-permutation-matrices-pt1/" rel="alternate" type="text/html" title="Powers of a permutation matrix - Part 1" /><published>2023-09-21T00:00:00-07:00</published><updated>2023-09-21T00:00:00-07:00</updated><id>/archive/powers-of-permutation-matrices-pt1</id><content type="html" xml:base="/archive/powers-of-permutation-matrices-pt1/">&lt;p&gt;I came across this problem while working through the MITOCW course on &lt;a href=&quot;https://ocw.mit.edu/courses/18-06sc-linear-algebra-fall-2011/pages/ax-b-and-the-four-subspaces/transposes-permutations-vector-spaces/&quot;&gt;Linear Algebra&lt;/a&gt;. The lectures are interesting in of themselves, but I got completely sidetracked when I started on this problem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post12/strang_problem.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This got me wondering if, given a permutation matrix &lt;em&gt;P&lt;/em&gt;, we’d always be able to find a &lt;em&gt;k&lt;/em&gt;, such that &lt;em&gt;P&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;I&lt;/em&gt;, where &lt;em&gt;I&lt;/em&gt; is the identity matrix. Equivalently, I wondered if, given a permutation of &lt;em&gt;n&lt;/em&gt; objects, one can always recover the initial arrangement by successfully performing the same permutation over and over again. That is, if there is always a &lt;em&gt;k&lt;/em&gt;, such that &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;e&lt;/em&gt; (where &lt;em&gt;e&lt;/em&gt; is the identity, a permutation that leaves the arrangement of objects unchanged) for a given permutation &lt;em&gt;p&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It turns out that the answer is that there is! Given any permutation of &lt;em&gt;n&lt;/em&gt; objects, you can recover the original arrangement by performing the same permutation on the object a specific number of times. The minimum number of times the permutation is to be repeated for a given permutation, depends on the internal structure of the permutation.&lt;/p&gt;

&lt;p&gt;To prove this, we have to first recognize that every permutation has atleast one cycle. A cycle is a permutation such that if you start with one element and track its position  as the permutation is repeatedly applied, it eventually returns to its original position. As an example consider this simple collection of four objects &lt;em&gt;( a, b, c, d )&lt;/em&gt;. If we apply the following permutation: &lt;em&gt;a -&amp;gt; b, b -&amp;gt; c, c -&amp;gt; d, and d -&amp;gt; a&lt;/em&gt; (call this permutation &lt;em&gt;p&lt;/em&gt;), and track the position of &lt;em&gt;c&lt;/em&gt;, we have &lt;em&gt;( d, a, b,&lt;/em&gt; &lt;strong&gt;c&lt;/strong&gt; &lt;em&gt;)&lt;/em&gt;. Applying the permutation again, i.e., &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;2&lt;/em&gt;&lt;/sup&gt;, we get &lt;em&gt;(&lt;/em&gt; &lt;strong&gt;c,&lt;/strong&gt; &lt;em&gt;d, a, b )&lt;/em&gt;. One more application (&lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;3&lt;/em&gt;&lt;/sup&gt;) gets us to &lt;em&gt;( b,&lt;/em&gt; &lt;strong&gt;c,&lt;/strong&gt; &lt;em&gt;d, a )&lt;/em&gt;, and finally &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;4&lt;/em&gt;&lt;/sup&gt; gives &lt;em&gt;( a, b,&lt;/em&gt; &lt;strong&gt;c,&lt;/strong&gt; &lt;em&gt;d )&lt;/em&gt; and we see that &lt;em&gt;c&lt;/em&gt;, as well as the other elements, has returned to its starting position.&lt;/p&gt;

&lt;p&gt;So why is it true that a permutation will have atleast one cycle? To understand this, consider a permutation on &lt;em&gt;n&lt;/em&gt; objects where a subset of the objects have changed positions. If no elements have changed position, then each element can thought of as being in a cycle of size 1. If more than one object has changed positions after the permutation has been applied, any one object in the subset will have moved to the position occupied by another object which will in turn have moved to a different position. For a finite subset of objects, this means that the position occupied by the initial object will now be occupied by a different object in the subset. If we suppose that this permutation does not have a cycle, it implies that the first object will never return to it’s orginal position no matter how many times the permutation is applied. This can only happen if the first object never reaches the position of the last object (which moves to the first position upon first application of the permutation). But this can only happen if the first object never reaches the position of the second-to-last object, as so on, until we are forced to conclude that the first object can never even reach the second position, implying that it did not move. This contradicts the statement that all objects in the subset changed positions. So the only way out is to admit that this the subset is in a cycle and that the size of the cycle is the number of elements in the subset.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://arunvijayshankar.github.io/archive/powers-of-permutation-matrices-pt2/&quot;&gt;Part 2&lt;/a&gt;, we will explore some specific permutations that are composed of simple cycles, and see what happens when the permuation is applied repeatedly to a set of objects.&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="linearalgebra" /><category term="permutations" /><summary type="html">I came across this problem while working through the MITOCW course on Linear Algebra. The lectures are interesting in of themselves, but I got completely sidetracked when I started on this problem:</summary></entry><entry><title type="html">Run a command recursively in all subdirectories</title><link href="/archive/run-a-command-recursively-in-all-subdirectories/" rel="alternate" type="text/html" title="Run a command recursively in all subdirectories" /><published>2022-12-23T00:00:00-08:00</published><updated>2022-12-23T00:00:00-08:00</updated><id>/archive/run-a-command-recursively-in-all-subdirectories</id><content type="html" xml:base="/archive/run-a-command-recursively-in-all-subdirectories/">&lt;p&gt;Suppose you wish to run a linux command in the current working directory, and in all of its subdirectories recursively. For example, I discovered that sometimes, running ‘make modules_install’ compresses all the modules as a .xz file in the various subdirectories. I read that the kernel does not care if a module is compressed, it can load the module in any case, but I did not know that at the time. I initially considered running “xz –decompress “ on every .xz file, but there are simply too many subsystem and driver directories, and it would extremely tedious. So I wrote a little script to do it:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/arunvijayshankar/a61fb0cd840f86e5f9ad4d4132497bf9&quot;&gt;run_cmd.py&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&quot;&quot;&quot;
* Script to run a system command recursively in every subdirectory 
* in a directory, including the current working directory
* Usage: run_cmd.py -[si] -c &amp;lt;command-to-run&amp;gt;
*
* Options:
*   -i 
*       Interactive mode. Prompts user to choose whether or not to 
*       run the command in a directory
*   -s
*       Skips the command for the working directory
*   -c
*       Command to be run
*
* Example: $python run_cmd.py -s -c &amp;lt;command-to-run&amp;gt;
* This will run &apos;ls -l &amp;gt; contents.txt&apos; in every subdirectory in the tree
* recursively, but will not run it in the working directory
*
* Author: Arun Vijayshankar
&quot;&quot;&quot;

import getopt
import os
import sys

def recursive_run_cmd_inter(root, cmd):
    for file in os.listdir(root):
        d = os.path.join(root, file)
        if os.path.isdir(d):
            os.chdir(d)
            run = input(&quot;Do you want to run &quot; + cmd + &quot; in: \n&quot; + os.getcwd() + &quot; [Y/No]&quot;)
            if str(run).upper() in [&apos;Y&apos;, &apos;YES&apos;]:
                print(&quot;running &quot; + cmd + &quot; in: &quot; + os.getcwd())
                os.system(cmd)
            recursive_run_cmd_inter(d, cmd)

def recursive_run_cmd(root, cmd):
    for file in os.listdir(root):
        d = os.path.join(root, file)
        if os.path.isdir(d):
            os.chdir(d)
            print(&quot;running &quot; + cmd + &quot; in: &quot; + os.getcwd())
            os.system(cmd)
            recursive_run_cmd(d, cmd)
            
def entry():
    argv = sys.argv[1:]
    try:
        options, args = getopt.getopt(argv, &quot;s:i:c&quot;, [])
    except:
        print(&quot;Usage: run_cmd.py -[si] -c &apos;&amp;lt;command-to-be-run&amp;gt;&apos;&quot;)

    root = os.getcwd()
    cmd = args[0]
    print(cmd)

    if &apos;-i&apos; in options[0]:
        recursive_run_cmd_inter(root, cmd)
    if &apos;-s&apos; in options[0]:
        if &apos;-i&apos; in options[0]:
            recursive_run_cmd_inter(root, cmd)
        else:
            recursive_run_cmd(root, cmd)
    else:
        os.chdir(root)
        print(&quot;running &quot; + cmd + &quot; in: &quot; + os.getcwd())
        os.system(cmd)
        recursive_run_cmd(root, cmd)

if __name__ == &quot;__main__&quot;:
    entry()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I tested it out on Ubuntu 20.04, and it seems to work. An addition that could be made is maybe the script can take a list of directory in which to run the command and run it in those only. I mightget around to doing this someday very soon.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="python" /><category term="linux" /><summary type="html">Suppose you wish to run a linux command in the current working directory, and in all of its subdirectories recursively. For example, I discovered that sometimes, running ‘make modules_install’ compresses all the modules as a .xz file in the various subdirectories. I read that the kernel does not care if a module is compressed, it can load the module in any case, but I did not know that at the time. I initially considered running “xz –decompress “ on every .xz file, but there are simply too many subsystem and driver directories, and it would extremely tedious. So I wrote a little script to do it:</summary></entry><entry><title type="html">A simple two channel multiplexer</title><link href="/archive/a-simple-two-channel-multiplexer/" rel="alternate" type="text/html" title="A simple two channel multiplexer" /><published>2022-11-29T00:00:00-08:00</published><updated>2022-11-29T00:00:00-08:00</updated><id>/archive/a-simple-two-channel-multiplexer</id><content type="html" xml:base="/archive/a-simple-two-channel-multiplexer/">&lt;p&gt;A couple of weeks ago, I came across this equation for a two channel multiplexer in a book on x86 Assembly&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Z = ( Y &amp;amp; S ) | ( X &amp;amp; ~S )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I was a little surprised at how simple the equation was and, out of curiosity, I drew a quick schematic of it&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post10/mplexer_schem.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It occured to me that I could build this for a simple and fun project. I had never really built any circuits before, and this seemed like a good first attempt. So I ordered the logic gates, and put it together once they were delivered, a few days later. It’s a very simple circuit and it was really easy to build.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post10/mplexer_pic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I used my beaglebone board to power the circuit, and for the input data streams for the two channels on the multiplexer. For the inputs I chose two pwm signals of 2Hz and 5Hz respectively and forwarded them from GPIO header pins on the beaglebone black. I kept the pwm signal frequency low to make the channel selection easier to observe. The circuit uses a push-button to flip the selection channel to choose between the two input channels. Here is a small demo of the circuit in action.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post10/demo_final_gif.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="digital-circuits" /><summary type="html">A couple of weeks ago, I came across this equation for a two channel multiplexer in a book on x86 Assembly</summary></entry><entry><title type="html">An embedded graphics framebuf driver for mnemOS</title><link href="/archive/an-embedded-graphics-framebuf-driver/" rel="alternate" type="text/html" title="An embedded graphics framebuf driver for mnemOS" /><published>2022-08-05T00:00:00-07:00</published><updated>2022-08-05T00:00:00-07:00</updated><id>/archive/an-embedded-graphics-framebuf-driver</id><content type="html" xml:base="/archive/an-embedded-graphics-framebuf-driver/">&lt;p&gt;Recently, I wrote a graphics framebuffer driver using the &lt;a href=&quot;https://docs.rs/embedded-graphics/latest/embedded_graphics/&quot;&gt;embedded-graphics crate&lt;/a&gt;. The driver was written for &lt;a href=&quot;https://mnemos-dev.jamesmunns.com/book/intro.html&quot;&gt;mnemOS&lt;/a&gt;, an operating system written in Rust. This contributions marks many firsts for me; first contribution to an OSS project, first piece of embedded software written, first driver written. The driver it self is quite simple. We use &lt;a href=&quot;https://docs.rs/embedded-graphics-simulator/latest/embedded_graphics_simulator/&quot;&gt;embedded-graphics-simulator&lt;/a&gt; to create a GUI window to display objects/text on. The driver then gives the user a chunk of heap memory onto which an object is drawn. ‘Draw’ is a trait in embedded-graphics where, given a collection of pixels each with a color and coordinate (the object), each pixel’s colour and coordinate (for 8bpp images) is stored in one byte of memory. The entire object can then be stored in a heap array.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post9/2022-08-05-21-40-33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the object has been drawn onto the chunk of memory, it can then be passed to the e-g-simulator window where it is displayed. However, as the e-g-simulator window only takes a ‘SimulatorDisplay’ object as an argument, the driver converts the raw bytes into an ‘image’, which can be passed back to user space and displayed on the window. If we are using a physical display, like a simple OLED display, the raw bytes can be sent over a suitable interface like SPI or I2C. Here is a sample what it looks like on the e-g-simulator:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/Screencast_from_07-27-2022_11_23_56_AM_AdobeExpress.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Contributing to an open source project (or any project, really) has been a goal of mine ever since I started learning programming in earnest. It was really rewarding to go from dreaming about making a contribution, to actually doing it. A small part of me still cannot believe I did it. I owe a huge shoutout to James Munns &lt;a href=&quot;https://twitter.com/bitshiftmask&quot;&gt;(@bitshiftmask)&lt;/a&gt; for encouraging me to just give it try when I expressed my desire to help out with this issue, but confessed that I wasn’t sure if I knew enough to do it. With this under my belt, I feel a lot more confident about my skills, and I am rearing to take on more projects and tasks. Next up is writing a networking driver for mnemOS using smoltcp, a TCP/IP stack for embedded/bare-metal rust projects. I plan to work on this in conjunction with continuing my learning journey in embedded systems.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="embedded" /><category term="device-drivers" /><category term="rust" /><summary type="html">Recently, I wrote a graphics framebuffer driver using the embedded-graphics crate. The driver was written for mnemOS, an operating system written in Rust. This contributions marks many firsts for me; first contribution to an OSS project, first piece of embedded software written, first driver written. The driver it self is quite simple. We use embedded-graphics-simulator to create a GUI window to display objects/text on. The driver then gives the user a chunk of heap memory onto which an object is drawn. ‘Draw’ is a trait in embedded-graphics where, given a collection of pixels each with a color and coordinate (the object), each pixel’s colour and coordinate (for 8bpp images) is stored in one byte of memory. The entire object can then be stored in a heap array.</summary></entry><entry><title type="html">What is scull</title><link href="/archive/what-is-scull/" rel="alternate" type="text/html" title="What is scull" /><published>2022-07-06T00:00:00-07:00</published><updated>2022-07-06T00:00:00-07:00</updated><id>/archive/what-is-scull</id><content type="html" xml:base="/archive/what-is-scull/">&lt;h2 id=&quot;scull-simple-character-utility-for-loading-localities&quot;&gt;Scull: Simple Character Utility for Loading Localities&lt;/h2&gt;

&lt;p&gt;“scull is char driver that acts on a memory area as though it were a device.”, is how scull is described in chapter 3 of 
&lt;a href=&quot;https://lwn.net/Kernel/LDD3/&quot;&gt;Linux Device Drivers&lt;/a&gt;. That seemed straightforward enough. Scull’s capabilities and allowed operations are described
in detail in the rest of the chapter. Once I finished the chapter, I wanted to learn more about what exactly scull was, and how I could go about
using it. But there seems to be surprisingly little information about it online. I thought I’d write a little something about what I have learned about 
it so far.&lt;/p&gt;

&lt;p&gt;Scull, if I understand it correctly, is fundamentally a kernel module. When the module is loaded, using insmod or modprobe, the kernel allocates some 
memory for scull, which then treats that memory region like a character device. Once loaded, scull will show up in /proc/devices:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post8/proc_devices.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A user can then use it as they would a regular character device. One can open and close it, read from it, or write to it.&lt;/p&gt;

&lt;p&gt;The source code for scull can be found &lt;a href=&quot;http://gauss.ececs.uc.edu/Courses/c4029/code/drivers/Scull/scull.html&quot;&gt;here&lt;/a&gt;. It can be compiled as a module 
by extracting the files from that archive and running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; at the source directory. Loading and Unloading of the module can be done using scull.load 
and scull.unload respectively. The shell scripts also clean up stale filesystem nodes, and setup new ones after loading the module. The newly created 
nodes will now show up under /dev:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post8/ls_dev.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;device-types-and-supported-operations&quot;&gt;Device types and supported operations&lt;/h2&gt;

&lt;p&gt;Scull supports different types of devices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;scull0 - scull3
    &lt;ul&gt;
      &lt;li&gt;These are global and persistant, meaning the data stored in them is shared between all the open file descriptors associated with it, and that the data is not lost if a file descriptor is closed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scullpipe0 - scullpipe3
    &lt;ul&gt;
      &lt;li&gt;These are FIFO devices which act as pipes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scullsingle, scullpriv, sculluid, scullwuid
    &lt;ul&gt;
      &lt;li&gt;These are similar to scull0, with limitations on when open can be called on them.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scull implements the following basic device methods:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;llseek():     Change current read/write position in a file.&lt;/li&gt;
  &lt;li&gt;read():       Retrieve data from the device.&lt;/li&gt;
  &lt;li&gt;write():      Write data to the device.&lt;/li&gt;
  &lt;li&gt;open():       First operation performed on the file.&lt;/li&gt;
  &lt;li&gt;ioctl():      Issue device specific commands, which are neither reading or writing.&lt;/li&gt;
  &lt;li&gt;release():    Invoked when file structure is released.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;using-scull&quot;&gt;Using scull&lt;/h2&gt;

&lt;p&gt;To use scull, we have have to first compile it to create scull module. The Makefile in the distribution comes configured, so all that needs to be done
is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo make&lt;/code&gt; from the source directory&lt;sup&gt;*&lt;/sup&gt;. You would need a machine running a linux kernel to compile it successfully, I’m pretty sure. Once the module is compiled and ready to be loaded, run the scull.load bash script to load the module, and create the filesystem nodes.&lt;/p&gt;

&lt;p&gt;The scull device is now ready to be written to, and read from. The scull distribution comes with a test file: sculltest.c&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* sculltest.c
 * A simple example of a C program to test some of the
 * operations of the &quot;/dev/scull&quot; device (a.k.a &quot;scull0&quot;),
 * and the 
 * ($Id: sculltest.c,v 1.1 2010/05/19 20:40:00 baker Exp baker $)
 */
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
   int fd, result, len;
   char buf[10];
   const char *str;
   if ((fd = open(&quot;/dev/scull&quot;, O_WRONLY)) == -1) {
      perror(&quot;1. open failed&quot;);
      return -1;
   }

   str = &quot;abcde&quot;; 
   len = strlen(str);
   if ((result = write(fd, str, len)) != len) {
      perror(&quot;1. write failed&quot;);
      return -1;
   }
   close(fd);

   if ((fd = open(&quot;/dev/scull&quot;, O_RDONLY)) == -1) {
      perror(&quot;2. open failed&quot;);
      return -1;
   }
   if ((result = read(fd, &amp;amp;buf, sizeof(buf))) != len) {
      fprintf(stdout, &quot;1. read failed, buf=%s&quot;,buf);
      return -1;
   } 
   buf[result] = &apos;\0&apos;;
   if (strncmp (buf, str, len)) {
      fprintf (stdout, &quot;failed: read back \&quot;%s\&quot;\n&quot;, buf);
   } else {
      fprintf (stdout, &quot;passed\n&quot;);
   }
   close(fd);

   ---SNIP---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Once the module is loaded, sculltest.c can be compiled and run to test out open, read, and write. Upon a read or write syscall, the corresponding 
function implemented in scull is called. The user can of course, write their own tests to test out supported operations.&lt;/p&gt;

&lt;p&gt;To gain a better understanding of scull and char drivers in general, I implemented a minimalistic version that supports only basic open/close, read/write operations, and only supports the global, persistant scull device type (scull0 - scull3). It can be found &lt;a href=&quot;https://github.com/arunvijayshankar/vichy&quot;&gt;here&lt;/a&gt;. The other major difference is the memory layout. In scull, each device is a linked list of structures, each of which points to a memory area of 4MB at most, though an array of a 1000 pointers, each pointing to a memory area of 4000 bytes. In vichy, each structure in the linked list making up the device points to just one memory area of 4000 bytes. These changes necessitated a few changes in the actual code, but they are small and cosmetic. Which is ok, I think. As a learner, it is a good confidence boost to make small changes to a project and learn by debugging all the issues you run into. This way you can learn the technology, and gain some actual coding experience.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;*&lt;/sup&gt;Note: On newer kernels (I’m running 5.19.0-rc3), scull hits compilations errors, mostly due to a deprecated method. The errors can be fixed with these patches&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;main.c: https://gist.github.com/arunvijayshankar/213e4dc0442ad3f4cd2b9785abc878a7&lt;/li&gt;
  &lt;li&gt;pipe.c: https://gist.github.com/arunvijayshankar/1cd5a2672fe540e196e9c27d163b0407&lt;/li&gt;
  &lt;li&gt;access.c: https://gist.github.com/arunvijayshankar/ae12566ac20707eb43afdf3e3d05a570&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="c" /><category term="linux" /><category term="device-drivers" /><summary type="html">Scull: Simple Character Utility for Loading Localities</summary></entry><entry><title type="html">Cross Compiling for BeagleBoard targets, and benchmarks</title><link href="/archive/cross-compiling-for-beagleboard-and-benchmarks/" rel="alternate" type="text/html" title="Cross Compiling for BeagleBoard targets, and benchmarks" /><published>2022-06-30T00:00:00-07:00</published><updated>2022-06-30T00:00:00-07:00</updated><id>/archive/cross-compiling-for-beagleboard-and-benchmarks</id><content type="html" xml:base="/archive/cross-compiling-for-beagleboard-and-benchmarks/">&lt;p&gt;I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;cross-compiler&quot;&gt;Cross Compiler&lt;/h2&gt;
    &lt;p&gt;The book uses a Raspberry Pi emulator on QEMU as a target, and uses the gcc/g++ arm cross compiler (arm-linux-gnueabi-gcc/g++) to build the binaries. As the RPi and BeagleBoard both run arm processors, I assumed that a binary that runs on Raspberry Pi would work on BeagleBoard as well. Spoiler alert: a binary compiled to run on an RPi, will not run on BeagleBoard. Google-fu helped me understand that the BeagleBoard needs a slightly different cross-compiler: arm-linux-gnueabi&lt;strong&gt;hf&lt;/strong&gt;-gcc/g++. Once I changed the Cmake file accordingly, I could run the program on BeagleBoard.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;uninitialized-pointers&quot;&gt;Uninitialized Pointers&lt;/h2&gt;
    &lt;p&gt;A small program that would create a shared memory region and then have two processes read from, and write to it, gave me unexpected results (and sometimes hit segmentation faults on the last read) on the beagleboard and RPi, whereas on the build system it crashed immediately. It turned out that I was derefencing an uninitialized pointer. On the build system the offending pointer was set to 0x0, but on the bbxm and raspberry pi, it was set to a random pointer. I’m not sure if this is something to do with the architecture or the compiler.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;system-timer&quot;&gt;System Timer&lt;/h2&gt;
    &lt;p&gt;One of the exercises involved writing a program to read the system timer on the rpi. This was a little bit of a challenge to port to the BBxM as the beagleboard’s system timer was structured a little differently. I wrote about this in more detail &lt;a href=&quot;https://arunvijayshankar.github.io/archive/reading-sync-timer-beagleboard-xm/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h2&gt;
    &lt;p&gt;Finally I ran lmbench on the build system, an x86_64 machine running ubuntu, and on the beagleboard, which is armv7 running debian:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BeagleBoard-xM benchmarks&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post7/bbxm_bench.png&quot; alt=&quot;BeagleBoard-xM Benchmarks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Build system benchmarks&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post7/x86_bench.png&quot; alt=&quot;Build system (x86_64) Benchmarks&quot; /&gt;&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="c" /><category term="cpp" /><category term="embedded" /><summary type="html">I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:</summary></entry></feed>
<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-10T19:32:45-07:00</updated><id>/feed.xml</id><title type="html">Arktos kai Mennos</title><subtitle>Arun Vijayshankar&apos;s blog</subtitle><entry><title type="html">Order of the Power Set</title><link href="/archive/order-of-power-set/" rel="alternate" type="text/html" title="Order of the Power Set" /><published>2023-10-10T00:00:00-07:00</published><updated>2023-10-10T00:00:00-07:00</updated><id>/archive/order-of-power-set</id><content type="html" xml:base="/archive/order-of-power-set/">&lt;p&gt;Here are two ways to determine the number of elements in the Power set of a finite set of objects. The set of all subsets of a set is called a power set, and the number of all the elements in a given set is called its order. Consider the following set &lt;em&gt;S = {a, b, c}&lt;/em&gt;. The order of this set is 3, and its power set is &lt;em&gt;P(S) = {O, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, S}&lt;/em&gt;. Notice that the power set contains all subsets of &lt;em&gt;S&lt;/em&gt;, including &lt;em&gt;S&lt;/em&gt;, and the empty set &lt;em&gt;O&lt;/em&gt;. We can see that &lt;em&gt;P(S)&lt;/em&gt; has 8 elements, so its order is 8. If you carried out a similar exercize for a set &lt;em&gt;S’ = {a, b, c, d}&lt;/em&gt;, we will find that its order is 16. It looks like the order of a the power set of a set with &lt;em&gt;n&lt;/em&gt; elements is &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;We can show that this is actually true. Let’s prove it in two ways. First let’s use mathematical induction, which is intuitive and clean, but a little dry IMO. Next, let’s show that it is true by just counting the elements (kind of). This is a lot more fun, and it’s nice to see how a couple of things come together to solve the problem.&lt;/p&gt;

&lt;p&gt;But first let’s do induction. Notice that if a set &lt;em&gt;S&lt;/em&gt; is empty, it has &lt;em&gt;n = 0&lt;/em&gt; elements. The power set, &lt;em&gt;P(S)&lt;/em&gt;, then only has one element - the empty set (which is also the entire set &lt;em&gt;S&lt;/em&gt;). So the order of the power set is 1, and &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;0&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;1&lt;/em&gt;, so the base case is true. Now let’s assume that it is true for the power set of a set with &lt;em&gt;n&lt;/em&gt; elements. So the power set of a set with &lt;em&gt;n&lt;/em&gt; elements would have order &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;. Let’s denote the elements of the power sets as &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;1&lt;/em&gt;&lt;/sub&gt;, &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;2&lt;/em&gt;&lt;/sub&gt;, …, &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;m&lt;/em&gt;&lt;/sub&gt;, where &lt;em&gt;m&lt;/em&gt; = &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;. Now consider adding one more element to &lt;em&gt;S&lt;/em&gt;, bringing the number of elements contained by it to &lt;em&gt;n+1&lt;/em&gt;. Adding this additional element to &lt;em&gt;S&lt;/em&gt; creates a whole bunch of new subsets, and we have to determine how many new subsets are created and add it to &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;, to find the order of the new power set of &lt;em&gt;S&lt;/em&gt;. Notice that all the new subsets of &lt;em&gt;S&lt;/em&gt; can be created by adding the new element to each of the subsets of &lt;em&gt;S&lt;/em&gt; with &lt;em&gt;n&lt;/em&gt; elements.&lt;/p&gt;

&lt;p&gt;For example, if &lt;em&gt;S&lt;/em&gt; = &lt;em&gt;{a, b}&lt;/em&gt;, then &lt;em&gt;P(S)&lt;/em&gt; = &lt;em&gt;{O, {a}, {b}, S}&lt;/em&gt;. If we add a third element, &lt;em&gt;c&lt;/em&gt;, to this set, then we get the new subsets -&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/new_sets.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essentially, by adding an additional element to &lt;em&gt;S&lt;/em&gt;, we are adding one additional subset to every subset in power set of the original set. So we have two times as many elements in the power set of a set with &lt;em&gt;n+1&lt;/em&gt; elements, as in the power set of one with &lt;em&gt;n&lt;/em&gt; elements. That is, the order of the power set of a set with &lt;em&gt;n+1&lt;/em&gt; elements is &lt;em&gt;2&lt;/em&gt; x &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;2&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n+1&lt;/em&gt;&lt;/sup&gt;, and we are done.&lt;/p&gt;

&lt;p&gt;Now let’s do it the fun way. Notice that we can determine the number of subsets of a set with &lt;em&gt;n&lt;/em&gt; elements but counting the number of subsets with 0 elements (the empty set), the number of subsets with 1 element (these are called singletons, there are &lt;em&gt;n&lt;/em&gt; of them), with 2 elements and so on, up to the number of subsets with &lt;em&gt;n&lt;/em&gt; elements (there’s one such subset - the entire set), and then adding them all up. To do this, let’s find the number of subsets with &lt;em&gt;k&lt;/em&gt; elements. This is equivalent to the number of ways of choosing &lt;em&gt;k&lt;/em&gt; objects from a collection of &lt;em&gt;n&lt;/em&gt; objects. We know that this is&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/nCk_new.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we have to sum the number of subsets with &lt;em&gt;k&lt;/em&gt; elements from &lt;em&gt;k&lt;/em&gt; = &lt;em&gt;0&lt;/em&gt; to &lt;em&gt;k&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt;. That is, the order of the power set is&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/order.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;All that is left to do is evaluating the sum on the right hand side of the above equation. It looks a little intimidating, and trying to evaluate it by expanding the sum and adding all the terms will turn out to be quite an effort. So maybe there’s another way. Notice that the sum looks remarkably similar to the sum in the binomial theorem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/binom_thm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In fact if we set &lt;em&gt;x&lt;/em&gt; = &lt;em&gt;y&lt;/em&gt; = &lt;em&gt;1&lt;/em&gt; in the binomial theorem, the sum will be the same as the sum in our expression for the order of the power set,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/binom_mod.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/xplusy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;which means&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post14/final.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and we’re done!&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="counting" /><category term="settheory" /><summary type="html">Here are two ways to determine the number of elements in the Power set of a finite set of objects. The set of all subsets of a set is called a power set, and the number of all the elements in a given set is called its order. Consider the following set S = {a, b, c}. The order of this set is 3, and its power set is P(S) = {O, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, S}. Notice that the power set contains all subsets of S, including S, and the empty set O. We can see that P(S) has 8 elements, so its order is 8. If you carried out a similar exercize for a set S’ = {a, b, c, d}, we will find that its order is 16. It looks like the order of a the power set of a set with n elements is 2n.</summary></entry><entry><title type="html">Powers of a permutation matrix - Part 2</title><link href="/archive/powers-of-permutation-matrices-pt2/" rel="alternate" type="text/html" title="Powers of a permutation matrix - Part 2" /><published>2023-10-01T00:00:00-07:00</published><updated>2023-10-01T00:00:00-07:00</updated><id>/archive/powers-of-permutation-matrices-pt2</id><content type="html" xml:base="/archive/powers-of-permutation-matrices-pt2/">&lt;p&gt;In &lt;a href=&quot;https://arunvijayshankar.github.io/archive/powers-of-permutation-matrices-pt1/&quot;&gt;Part 1&lt;/a&gt;, we saw how every permutation has at least one cycle, and that the size of the cycle is the number of elements in the cycle. If we now consider a permutation that is one big cycle of all the elements in our set, then we can easily see that if we apply the same permutation &lt;em&gt;n&lt;/em&gt; times, &lt;em&gt;n&lt;/em&gt; being the number of elements in the set, all elements return to the positions with which they started out. So &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;e&lt;/em&gt; for such a permutation, where once again, &lt;em&gt;e&lt;/em&gt; is the identity.&lt;/p&gt;

&lt;p&gt;But what about permutations that are not just one cycle of all elements? What if the permutation consists of a combinations of cycles of different cycles and/or fixed points (elements that remain fixed in their positions upon application of a permutation are called fixed points). To explore this further, let us consider a couple of specific examples.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt; The permutation is one in which two elements in the set switch places, the rest are fixed points - In this case, there is one cycle of size two, and the rest are fixed points, so they are all in cycles of size one. So if we apply the permutation for a second time, both elements that switched places return to their original position, and the rest will have remained in the same position with which they started out. So if &lt;em&gt;p&lt;/em&gt; denotes this particular permutation, then &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 2 &lt;/li&gt;
	&lt;li&gt;The permutation consists of two cycles of size &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; respectively - Here, we immediately see that the first cycle with return to its starting arrangement after &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; applications of the permutation and the second cycle will return to its starting arrangement after &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; applications. To calculate how many applications of the permutation are needed for both cycles to return to the starting configuration, notice that either cycle will return to the start when the permutation is applied &lt;em&gt;mk&lt;/em&gt; times, where &lt;em&gt;m&lt;/em&gt; is a positive integer. So this means that if the permutation is applied &lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; times, both cycles will have returned to their original positions (notice that if &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;qk&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; then both cycles will return to the starting positions after just &lt;em&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; applications of the permutation). That is, &lt;em&gt;p&lt;sup&gt;k&lt;sub&gt;1&lt;/sub&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/sup&gt;&lt;/em&gt; = &lt;em&gt;e&lt;/em&gt;&lt;/li&gt; 
&lt;/ol&gt;

&lt;p&gt;Let’s stop here for now, and in Part 3 let’s explore permutations that are a little more complex, and finally try and nail down the answer for any generic permutation.&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="linearalgebra" /><category term="permutations" /><summary type="html">In Part 1, we saw how every permutation has at least one cycle, and that the size of the cycle is the number of elements in the cycle. If we now consider a permutation that is one big cycle of all the elements in our set, then we can easily see that if we apply the same permutation n times, n being the number of elements in the set, all elements return to the positions with which they started out. So pn = e for such a permutation, where once again, e is the identity.</summary></entry><entry><title type="html">Powers of a permutation matrix - Part 1</title><link href="/archive/powers-of-permutation-matrices-pt1/" rel="alternate" type="text/html" title="Powers of a permutation matrix - Part 1" /><published>2023-09-21T00:00:00-07:00</published><updated>2023-09-21T00:00:00-07:00</updated><id>/archive/powers-of-permutation-matrices-pt1</id><content type="html" xml:base="/archive/powers-of-permutation-matrices-pt1/">&lt;p&gt;I came across this problem while working through the MITOCW course on &lt;a href=&quot;https://ocw.mit.edu/courses/18-06sc-linear-algebra-fall-2011/pages/ax-b-and-the-four-subspaces/transposes-permutations-vector-spaces/&quot;&gt;Linear Algebra&lt;/a&gt;. The lectures are interesting in of themselves, but I got completely sidetracked when I started on this problem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post12/strang_problem.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This got me wondering if, given a permutation matrix &lt;em&gt;P&lt;/em&gt;, we’d always be able to find a &lt;em&gt;k&lt;/em&gt;, such that &lt;em&gt;P&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;I&lt;/em&gt;, where &lt;em&gt;I&lt;/em&gt; is the identity matrix. Equivalently, I wondered if, given a permutation of &lt;em&gt;n&lt;/em&gt; objects, one can always recover the initial arrangement by successfully performing the same permutation over and over again. That is, if there is always a &lt;em&gt;k&lt;/em&gt;, such that &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;e&lt;/em&gt; (where &lt;em&gt;e&lt;/em&gt; is the identity, a permutation that leaves the arrangement of objects unchanged) for a given permutation &lt;em&gt;p&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It turns out that the answer is that there is! Given any permutation of &lt;em&gt;n&lt;/em&gt; objects, you can recover the original arrangement by performing the same permutation on the object a specific number of times. The minimum number of times the permutation is to be repeated for a given permutation, depends on the internal structure of the permutation.&lt;/p&gt;

&lt;p&gt;To prove this, we have to first recognize that every permutation has atleast one cycle. A cycle is a permutation such that if you start with one element and track its position  as the permutation is repeatedly applied, it eventually returns to its original position. As an example consider this simple collection of four objects &lt;em&gt;( a, b, c, d )&lt;/em&gt;. If we apply the following permutation: &lt;em&gt;a -&amp;gt; b, b -&amp;gt; c, c -&amp;gt; d, and d -&amp;gt; a&lt;/em&gt; (call this permutation &lt;em&gt;p&lt;/em&gt;), and track the position of &lt;em&gt;c&lt;/em&gt;, we have &lt;em&gt;( d, a, b,&lt;/em&gt; &lt;strong&gt;c&lt;/strong&gt; &lt;em&gt;)&lt;/em&gt;. Applying the permutation again, i.e., &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;2&lt;/em&gt;&lt;/sup&gt;, we get &lt;em&gt;(&lt;/em&gt; &lt;strong&gt;c,&lt;/strong&gt; &lt;em&gt;d, a, b )&lt;/em&gt;. One more application (&lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;3&lt;/em&gt;&lt;/sup&gt;) gets us to &lt;em&gt;( b,&lt;/em&gt; &lt;strong&gt;c,&lt;/strong&gt; &lt;em&gt;d, a )&lt;/em&gt;, and finally &lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;4&lt;/em&gt;&lt;/sup&gt; gives &lt;em&gt;( a, b,&lt;/em&gt; &lt;strong&gt;c,&lt;/strong&gt; &lt;em&gt;d )&lt;/em&gt; and we see that &lt;em&gt;c&lt;/em&gt;, as well as the other elements, has returned to its starting position.&lt;/p&gt;

&lt;p&gt;So why is it true that a permutation will have atleast one cycle? To understand this, consider a permutation on &lt;em&gt;n&lt;/em&gt; objects where a subset of the objects have changed positions. If no elements have changed position, then each element can thought of as being in a cycle of size 1. If more than one object has changed positions after the permutation has been applied, any one object in the subset will have moved to the position occupied by another object which will in turn have moved to a different position. For a finite subset of objects, this means that the position occupied by the initial object will now be occupied by a different object in the subset. If we suppose that this permutation does not have a cycle, it implies that the first object will never return to it’s orginal position no matter how many times the permutation is applied. This can only happen if the first object never reaches the position of the last object (which moves to the first position upon first application of the permutation). But this can only happen if the first object never reaches the position of the second-to-last object, as so on, until we are forced to conclude that the first object can never even reach the second position, implying that it did not move. This contradicts the statement that all objects in the subset changed positions. So the only way out is to admit that this the subset is in a cycle and that the size of the cycle is the number of elements in the subset.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://arunvijayshankar.github.io/archive/powers-of-permutation-matrices-pt2/&quot;&gt;Part 2&lt;/a&gt;, we will explore some specific permutations that are composed of simple cycles, and see what happens when the permuation is applied repeatedly to a set of objects.&lt;/p&gt;</content><author><name>Arun</name></author><category term="mathematics" /><category term="linearalgebra" /><category term="permutations" /><summary type="html">I came across this problem while working through the MITOCW course on Linear Algebra. The lectures are interesting in of themselves, but I got completely sidetracked when I started on this problem:</summary></entry><entry><title type="html">Run a command recursively in all subdirectories</title><link href="/archive/run-a-command-recursively-in-all-subdirectories/" rel="alternate" type="text/html" title="Run a command recursively in all subdirectories" /><published>2022-12-23T00:00:00-08:00</published><updated>2022-12-23T00:00:00-08:00</updated><id>/archive/run-a-command-recursively-in-all-subdirectories</id><content type="html" xml:base="/archive/run-a-command-recursively-in-all-subdirectories/">&lt;p&gt;Suppose you wish to run a linux command in the current working directory, and in all of its subdirectories recursively. For example, I discovered that sometimes, running ‘make modules_install’ compresses all the modules as a .xz file in the various subdirectories. I read that the kernel does not care if a module is compressed, it can load the module in any case, but I did not know that at the time. I initially considered running “xz –decompress “ on every .xz file, but there are simply too many subsystem and driver directories, and it would extremely tedious. So I wrote a little script to do it:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/arunvijayshankar/a61fb0cd840f86e5f9ad4d4132497bf9&quot;&gt;run_cmd.py&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&quot;&quot;&quot;
* Script to run a system command recursively in every subdirectory 
* in a directory, including the current working directory
* Usage: run_cmd.py -[si] -c &amp;lt;command-to-run&amp;gt;
*
* Options:
*   -i 
*       Interactive mode. Prompts user to choose whether or not to 
*       run the command in a directory
*   -s
*       Skips the command for the working directory
*   -c
*       Command to be run
*
* Example: $python run_cmd.py -s -c &amp;lt;command-to-run&amp;gt;
* This will run &apos;ls -l &amp;gt; contents.txt&apos; in every subdirectory in the tree
* recursively, but will not run it in the working directory
*
* Author: Arun Vijayshankar
&quot;&quot;&quot;

import getopt
import os
import sys

def recursive_run_cmd_inter(root, cmd):
    for file in os.listdir(root):
        d = os.path.join(root, file)
        if os.path.isdir(d):
            os.chdir(d)
            run = input(&quot;Do you want to run &quot; + cmd + &quot; in: \n&quot; + os.getcwd() + &quot; [Y/No]&quot;)
            if str(run).upper() in [&apos;Y&apos;, &apos;YES&apos;]:
                print(&quot;running &quot; + cmd + &quot; in: &quot; + os.getcwd())
                os.system(cmd)
            recursive_run_cmd_inter(d, cmd)

def recursive_run_cmd(root, cmd):
    for file in os.listdir(root):
        d = os.path.join(root, file)
        if os.path.isdir(d):
            os.chdir(d)
            print(&quot;running &quot; + cmd + &quot; in: &quot; + os.getcwd())
            os.system(cmd)
            recursive_run_cmd(d, cmd)
            
def entry():
    argv = sys.argv[1:]
    try:
        options, args = getopt.getopt(argv, &quot;s:i:c&quot;, [])
    except:
        print(&quot;Usage: run_cmd.py -[si] -c &apos;&amp;lt;command-to-be-run&amp;gt;&apos;&quot;)

    root = os.getcwd()
    cmd = args[0]
    print(cmd)

    if &apos;-i&apos; in options[0]:
        recursive_run_cmd_inter(root, cmd)
    if &apos;-s&apos; in options[0]:
        if &apos;-i&apos; in options[0]:
            recursive_run_cmd_inter(root, cmd)
        else:
            recursive_run_cmd(root, cmd)
    else:
        os.chdir(root)
        print(&quot;running &quot; + cmd + &quot; in: &quot; + os.getcwd())
        os.system(cmd)
        recursive_run_cmd(root, cmd)

if __name__ == &quot;__main__&quot;:
    entry()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I tested it out on Ubuntu 20.04, and it seems to work. An addition that could be made is maybe the script can take a list of directory in which to run the command and run it in those only. I mightget around to doing this someday very soon.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="python" /><category term="linux" /><summary type="html">Suppose you wish to run a linux command in the current working directory, and in all of its subdirectories recursively. For example, I discovered that sometimes, running ‘make modules_install’ compresses all the modules as a .xz file in the various subdirectories. I read that the kernel does not care if a module is compressed, it can load the module in any case, but I did not know that at the time. I initially considered running “xz –decompress “ on every .xz file, but there are simply too many subsystem and driver directories, and it would extremely tedious. So I wrote a little script to do it:</summary></entry><entry><title type="html">A simple two channel multiplexer</title><link href="/archive/a-simple-two-channel-multiplexer/" rel="alternate" type="text/html" title="A simple two channel multiplexer" /><published>2022-11-29T00:00:00-08:00</published><updated>2022-11-29T00:00:00-08:00</updated><id>/archive/a-simple-two-channel-multiplexer</id><content type="html" xml:base="/archive/a-simple-two-channel-multiplexer/">&lt;p&gt;A couple of weeks ago, I came across this equation for a two channel multiplexer in a book on x86 Assembly&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Z = ( Y &amp;amp; S ) | ( X &amp;amp; ~S )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I was a little surprised at how simple the equation was and, out of curiosity, I drew a quick schematic of it&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post10/mplexer_schem.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It occured to me that I could build this for a simple and fun project. I had never really built any circuits before, and this seemed like a good first attempt. So I ordered the logic gates, and put it together once they were delivered, a few days later. It’s a very simple circuit and it was really easy to build.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post10/mplexer_pic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I used my beaglebone board to power the circuit, and for the input data streams for the two channels on the multiplexer. For the inputs I chose two pwm signals of 2Hz and 5Hz respectively and forwarded them from GPIO header pins on the beaglebone black. I kept the pwm signal frequency low to make the channel selection easier to observe. The circuit uses a push-button to flip the selection channel to choose between the two input channels. Here is a small demo of the circuit in action.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post10/demo_final_gif.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="digital-circuits" /><summary type="html">A couple of weeks ago, I came across this equation for a two channel multiplexer in a book on x86 Assembly</summary></entry><entry><title type="html">An embedded graphics framebuf driver for mnemOS</title><link href="/archive/an-embedded-graphics-framebuf-driver/" rel="alternate" type="text/html" title="An embedded graphics framebuf driver for mnemOS" /><published>2022-08-05T00:00:00-07:00</published><updated>2022-08-05T00:00:00-07:00</updated><id>/archive/an-embedded-graphics-framebuf-driver</id><content type="html" xml:base="/archive/an-embedded-graphics-framebuf-driver/">&lt;p&gt;Recently, I wrote a graphics framebuffer driver using the &lt;a href=&quot;https://docs.rs/embedded-graphics/latest/embedded_graphics/&quot;&gt;embedded-graphics crate&lt;/a&gt;. The driver was written for &lt;a href=&quot;https://mnemos-dev.jamesmunns.com/book/intro.html&quot;&gt;mnemOS&lt;/a&gt;, an operating system written in Rust. This contributions marks many firsts for me; first contribution to an OSS project, first piece of embedded software written, first driver written. The driver it self is quite simple. We use &lt;a href=&quot;https://docs.rs/embedded-graphics-simulator/latest/embedded_graphics_simulator/&quot;&gt;embedded-graphics-simulator&lt;/a&gt; to create a GUI window to display objects/text on. The driver then gives the user a chunk of heap memory onto which an object is drawn. ‘Draw’ is a trait in embedded-graphics where, given a collection of pixels each with a color and coordinate (the object), each pixel’s colour and coordinate (for 8bpp images) is stored in one byte of memory. The entire object can then be stored in a heap array.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post9/2022-08-05-21-40-33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the object has been drawn onto the chunk of memory, it can then be passed to the e-g-simulator window where it is displayed. However, as the e-g-simulator window only takes a ‘SimulatorDisplay’ object as an argument, the driver converts the raw bytes into an ‘image’, which can be passed back to user space and displayed on the window. If we are using a physical display, like a simple OLED display, the raw bytes can be sent over a suitable interface like SPI or I2C. Here is a sample what it looks like on the e-g-simulator:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/Screencast_from_07-27-2022_11_23_56_AM_AdobeExpress.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Contributing to an open source project (or any project, really) has been a goal of mine ever since I started learning programming in earnest. It was really rewarding to go from dreaming about making a contribution, to actually doing it. A small part of me still cannot believe I did it. I owe a huge shoutout to James Munns &lt;a href=&quot;https://twitter.com/bitshiftmask&quot;&gt;(@bitshiftmask)&lt;/a&gt; for encouraging me to just give it try when I expressed my desire to help out with this issue, but confessed that I wasn’t sure if I knew enough to do it. With this under my belt, I feel a lot more confident about my skills, and I am rearing to take on more projects and tasks. Next up is writing a networking driver for mnemOS using smoltcp, a TCP/IP stack for embedded/bare-metal rust projects. I plan to work on this in conjunction with continuing my learning journey in embedded systems.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="embedded" /><category term="device-drivers" /><category term="rust" /><summary type="html">Recently, I wrote a graphics framebuffer driver using the embedded-graphics crate. The driver was written for mnemOS, an operating system written in Rust. This contributions marks many firsts for me; first contribution to an OSS project, first piece of embedded software written, first driver written. The driver it self is quite simple. We use embedded-graphics-simulator to create a GUI window to display objects/text on. The driver then gives the user a chunk of heap memory onto which an object is drawn. ‘Draw’ is a trait in embedded-graphics where, given a collection of pixels each with a color and coordinate (the object), each pixel’s colour and coordinate (for 8bpp images) is stored in one byte of memory. The entire object can then be stored in a heap array.</summary></entry><entry><title type="html">What is scull</title><link href="/archive/what-is-scull/" rel="alternate" type="text/html" title="What is scull" /><published>2022-07-06T00:00:00-07:00</published><updated>2022-07-06T00:00:00-07:00</updated><id>/archive/what-is-scull</id><content type="html" xml:base="/archive/what-is-scull/">&lt;h2 id=&quot;scull-simple-character-utility-for-loading-localities&quot;&gt;Scull: Simple Character Utility for Loading Localities&lt;/h2&gt;

&lt;p&gt;“scull is char driver that acts on a memory area as though it were a device.”, is how scull is described in chapter 3 of 
&lt;a href=&quot;https://lwn.net/Kernel/LDD3/&quot;&gt;Linux Device Drivers&lt;/a&gt;. That seemed straightforward enough. Scull’s capabilities and allowed operations are described
in detail in the rest of the chapter. Once I finished the chapter, I wanted to learn more about what exactly scull was, and how I could go about
using it. But there seems to be surprisingly little information about it online. I thought I’d write a little something about what I have learned about 
it so far.&lt;/p&gt;

&lt;p&gt;Scull, if I understand it correctly, is fundamentally a kernel module. When the module is loaded, using insmod or modprobe, the kernel allocates some 
memory for scull, which then treats that memory region like a character device. Once loaded, scull will show up in /proc/devices:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post8/proc_devices.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A user can then use it as they would a regular character device. One can open and close it, read from it, or write to it.&lt;/p&gt;

&lt;p&gt;The source code for scull can be found &lt;a href=&quot;http://gauss.ececs.uc.edu/Courses/c4029/code/drivers/Scull/scull.html&quot;&gt;here&lt;/a&gt;. It can be compiled as a module 
by extracting the files from that archive and running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; at the source directory. Loading and Unloading of the module can be done using scull.load 
and scull.unload respectively. The shell scripts also clean up stale filesystem nodes, and setup new ones after loading the module. The newly created 
nodes will now show up under /dev:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post8/ls_dev.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;device-types-and-supported-operations&quot;&gt;Device types and supported operations&lt;/h2&gt;

&lt;p&gt;Scull supports different types of devices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;scull0 - scull3
    &lt;ul&gt;
      &lt;li&gt;These are global and persistant, meaning the data stored in them is shared between all the open file descriptors associated with it, and that the data is not lost if a file descriptor is closed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scullpipe0 - scullpipe3
    &lt;ul&gt;
      &lt;li&gt;These are FIFO devices which act as pipes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scullsingle, scullpriv, sculluid, scullwuid
    &lt;ul&gt;
      &lt;li&gt;These are similar to scull0, with limitations on when open can be called on them.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scull implements the following basic device methods:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;llseek():     Change current read/write position in a file.&lt;/li&gt;
  &lt;li&gt;read():       Retrieve data from the device.&lt;/li&gt;
  &lt;li&gt;write():      Write data to the device.&lt;/li&gt;
  &lt;li&gt;open():       First operation performed on the file.&lt;/li&gt;
  &lt;li&gt;ioctl():      Issue device specific commands, which are neither reading or writing.&lt;/li&gt;
  &lt;li&gt;release():    Invoked when file structure is released.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;using-scull&quot;&gt;Using scull&lt;/h2&gt;

&lt;p&gt;To use scull, we have have to first compile it to create scull module. The Makefile in the distribution comes configured, so all that needs to be done
is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo make&lt;/code&gt; from the source directory&lt;sup&gt;*&lt;/sup&gt;. You would need a machine running a linux kernel to compile it successfully, I’m pretty sure. Once the module is compiled and ready to be loaded, run the scull.load bash script to load the module, and create the filesystem nodes.&lt;/p&gt;

&lt;p&gt;The scull device is now ready to be written to, and read from. The scull distribution comes with a test file: sculltest.c&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* sculltest.c
 * A simple example of a C program to test some of the
 * operations of the &quot;/dev/scull&quot; device (a.k.a &quot;scull0&quot;),
 * and the 
 * ($Id: sculltest.c,v 1.1 2010/05/19 20:40:00 baker Exp baker $)
 */
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
   int fd, result, len;
   char buf[10];
   const char *str;
   if ((fd = open(&quot;/dev/scull&quot;, O_WRONLY)) == -1) {
      perror(&quot;1. open failed&quot;);
      return -1;
   }

   str = &quot;abcde&quot;; 
   len = strlen(str);
   if ((result = write(fd, str, len)) != len) {
      perror(&quot;1. write failed&quot;);
      return -1;
   }
   close(fd);

   if ((fd = open(&quot;/dev/scull&quot;, O_RDONLY)) == -1) {
      perror(&quot;2. open failed&quot;);
      return -1;
   }
   if ((result = read(fd, &amp;amp;buf, sizeof(buf))) != len) {
      fprintf(stdout, &quot;1. read failed, buf=%s&quot;,buf);
      return -1;
   } 
   buf[result] = &apos;\0&apos;;
   if (strncmp (buf, str, len)) {
      fprintf (stdout, &quot;failed: read back \&quot;%s\&quot;\n&quot;, buf);
   } else {
      fprintf (stdout, &quot;passed\n&quot;);
   }
   close(fd);

   ---SNIP---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Once the module is loaded, sculltest.c can be compiled and run to test out open, read, and write. Upon a read or write syscall, the corresponding 
function implemented in scull is called. The user can of course, write their own tests to test out supported operations.&lt;/p&gt;

&lt;p&gt;To gain a better understanding of scull and char drivers in general, I implemented a minimalistic version that supports only basic open/close, read/write operations, and only supports the global, persistant scull device type (scull0 - scull3). It can be found &lt;a href=&quot;https://github.com/arunvijayshankar/vichy&quot;&gt;here&lt;/a&gt;. The other major difference is the memory layout. In scull, each device is a linked list of structures, each of which points to a memory area of 4MB at most, though an array of a 1000 pointers, each pointing to a memory area of 4000 bytes. In vichy, each structure in the linked list making up the device points to just one memory area of 4000 bytes. These changes necessitated a few changes in the actual code, but they are small and cosmetic. Which is ok, I think. As a learner, it is a good confidence boost to make small changes to a project and learn by debugging all the issues you run into. This way you can learn the technology, and gain some actual coding experience.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;*&lt;/sup&gt;Note: On newer kernels (I’m running 5.19.0-rc3), scull hits compilations errors, mostly due to a deprecated method. The errors can be fixed with these patches&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;main.c: https://gist.github.com/arunvijayshankar/213e4dc0442ad3f4cd2b9785abc878a7&lt;/li&gt;
  &lt;li&gt;pipe.c: https://gist.github.com/arunvijayshankar/1cd5a2672fe540e196e9c27d163b0407&lt;/li&gt;
  &lt;li&gt;access.c: https://gist.github.com/arunvijayshankar/ae12566ac20707eb43afdf3e3d05a570&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="c" /><category term="linux" /><category term="device-drivers" /><summary type="html">Scull: Simple Character Utility for Loading Localities</summary></entry><entry><title type="html">Cross Compiling for BeagleBoard targets, and benchmarks</title><link href="/archive/cross-compiling-for-beagleboard-and-benchmarks/" rel="alternate" type="text/html" title="Cross Compiling for BeagleBoard targets, and benchmarks" /><published>2022-06-30T00:00:00-07:00</published><updated>2022-06-30T00:00:00-07:00</updated><id>/archive/cross-compiling-for-beagleboard-and-benchmarks</id><content type="html" xml:base="/archive/cross-compiling-for-beagleboard-and-benchmarks/">&lt;p&gt;I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;cross-compiler&quot;&gt;Cross Compiler&lt;/h2&gt;
    &lt;p&gt;The book uses a Raspberry Pi emulator on QEMU as a target, and uses the gcc/g++ arm cross compiler (arm-linux-gnueabi-gcc/g++) to build the binaries. As the RPi and BeagleBoard both run arm processors, I assumed that a binary that runs on Raspberry Pi would work on BeagleBoard as well. Spoiler alert: a binary compiled to run on an RPi, will not run on BeagleBoard. Google-fu helped me understand that the BeagleBoard needs a slightly different cross-compiler: arm-linux-gnueabi&lt;strong&gt;hf&lt;/strong&gt;-gcc/g++. Once I changed the Cmake file accordingly, I could run the program on BeagleBoard.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;uninitialized-pointers&quot;&gt;Uninitialized Pointers&lt;/h2&gt;
    &lt;p&gt;A small program that would create a shared memory region and then have two processes read from, and write to it, gave me unexpected results (and sometimes hit segmentation faults on the last read) on the beagleboard and RPi, whereas on the build system it crashed immediately. It turned out that I was derefencing an uninitialized pointer. On the build system the offending pointer was set to 0x0, but on the bbxm and raspberry pi, it was set to a random pointer. I’m not sure if this is something to do with the architecture or the compiler.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;system-timer&quot;&gt;System Timer&lt;/h2&gt;
    &lt;p&gt;One of the exercises involved writing a program to read the system timer on the rpi. This was a little bit of a challenge to port to the BBxM as the beagleboard’s system timer was structured a little differently. I wrote about this in more detail &lt;a href=&quot;https://arunvijayshankar.github.io/archive/reading-sync-timer-beagleboard-xm/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h2&gt;
    &lt;p&gt;Finally I ran lmbench on the build system, an x86_64 machine running ubuntu, and on the beagleboard, which is armv7 running debian:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BeagleBoard-xM benchmarks&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post7/bbxm_bench.png&quot; alt=&quot;BeagleBoard-xM Benchmarks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Build system benchmarks&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post7/x86_bench.png&quot; alt=&quot;Build system (x86_64) Benchmarks&quot; /&gt;&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="c" /><category term="cpp" /><category term="embedded" /><summary type="html">I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:</summary></entry><entry><title type="html">Reading the System Timer on Beagleboard XM</title><link href="/archive/reading-sync-timer-beagleboard-xm/" rel="alternate" type="text/html" title="Reading the System Timer on Beagleboard XM" /><published>2022-06-10T00:00:00-07:00</published><updated>2022-06-10T00:00:00-07:00</updated><id>/archive/reading-sync-timer-beagleboard-xm</id><content type="html" xml:base="/archive/reading-sync-timer-beagleboard-xm/">&lt;p&gt;One of the exercises in the book ‘Embedded Programming with Modern C++ Cookbook’ is to read the System Timer on a RaspberryPi. The system timer peripheral on a raspberry pi provides a 64 bit free running counter that increments with every clock tick. Although the book uses QEMU to run a rPi emulator as the target for the programs, I have been using a Beagleboard XM as the target. So far, there have been some changes, but no significant differences in code for the raspberry pi vs the beagleboard. I assumed that reading the system timer would be no different. This was of course, not the case. For a beginner like myself, it was quite challenging to get it working on the bbxm.&lt;/p&gt;

&lt;p&gt;The book starts off by hard coding the base address of the rPi system timer, and a struct to store the two 32 bit sections of the timer:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr uint32_t kTimerBase = 0x3F003000;

struct SystemTimer {
  uint32_t CS;
  uint32_t counter_lo;
  uint32_t counter_hi;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The sync timer address is then mapped using mmap as a shared map and cast as a struct pointer to read the value into counter_lo and counter_hi, which are added together to get the actual timer value.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int memfd = open(&quot;/dev/mem&quot;, O_RDWR | O_SYNC);

SystemTimer *timer = (SystemTimer*)mmap(NULL, sizeof(SystemTimer),
PROT_READ|PROT_WRITE, MAP_SHARED,
memfd, kTimerBase);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I knew that it was unlikely that the timer base address will be the same on the bbxm, so the first challenge was to find the right address. I looked for the AM37 manual online, and it turns out that Texas Instruments will let you download it if you register an account with them. So now I have a TI developer account. Oh, and the manual. The manual listed the Sync Timer base address of the 32 kHz clock as 0x48320000, and that the register was 32 bits long. I made the changes, and compiled the build. But when I ran it, the program would only print out one value&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System timer: 64
System timer: 64
System timer: 64
System timer: 64
System timer: 64
System timer: 64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It looked as if the timer was not updating with every clock tick. My first suspicion was that address was wrong somehow, or that the mapping was not correct. I spent a considerable amount of time trying to get to the bottom of that, all to no avail. The address was as noted in the manual, and there did not seem to be anything wrong with the mapping. So I did the only thing I could think of, and reached out to the good folks on the internet. One person suggested that maybe the timer was not enabled. This seemed like a plausible root cause, so I went back to the manual and started digging to find out how to check if the timer is disabled. I did find the timer controls, but I honestly did not really understand it. But what I did accidentally discover was that even though the base address for the sync timer on the bbxm is 0x48320000, the actual value of the timer is stored at a 0x0010 offset!&lt;/p&gt;

&lt;p&gt;So I dutifully changed the address to 0x48320010, re-compiled, and ran it. I hit a Bus Error. What is a bus error now? I asked my browser, which said that it was a hardware error, letting the OS know that CPU cannot access the memory that the process is trying to access. So I was back to some issue with the address. I was convinced that the physical address was correct this time, so maybe there was something wrong with the virtual address? After some more scouring of the internet, I found this &lt;a href=&quot;https://bakhi.github.io/devmem/&quot;&gt;post&lt;/a&gt;. Reading through it, I finally understood that mmap was creating a new mapping in the virtual address space starting at the physical address we specify in the mmap call. For some reason that I don’t still understand, providing the physical address + the offset to mmap was returning a bad virtual address. But maybe mapping the timer base address first, and then adding the offset might fix it? I tried this, and it worked! The value updated by ~400 units everytime I ran the binary. I also understood why the program was not updating when I ran it with just the base address. The first 4 bytes of the Sync Timer stored just the timer version. I was just reading this constant over and over again. But after first mapping the base physical address and adding the offset, the program read the actual timer value everytime. Here is the entire program (minus error checking):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr uint32_t kTimerBase = 0x48320000;
constexpr uint32_t timer_offset = 0x0010; 


int main() {
    int memfd = open(&quot;/dev/mem&quot;, O_RDWR | O_SYNC);

    void *map_base = mmap(NULL, sizeof(uint32_t),
    PROT_READ | PROT_WRITE, MAP_SHARED,
    memfd, kTimerBase);

    uint32_t *timer = (uint32_t *)((char *)map_base + timer_offset);

    for (int i = 0; i &amp;lt; 10; i++) {
        std::cout &amp;lt;&amp;lt; &quot;System timer: &quot; &amp;lt;&amp;lt; *timer;
        std::cout &amp;lt;&amp;lt; std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As an aside, the program as specified in the book, did not run correctly on the rPi emulator either. But once I made the offset changes above to the code, it read the timer value correctly on every run.&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="cpp" /><category term="embedded" /><summary type="html">One of the exercises in the book ‘Embedded Programming with Modern C++ Cookbook’ is to read the System Timer on a RaspberryPi. The system timer peripheral on a raspberry pi provides a 64 bit free running counter that increments with every clock tick. Although the book uses QEMU to run a rPi emulator as the target for the programs, I have been using a Beagleboard XM as the target. So far, there have been some changes, but no significant differences in code for the raspberry pi vs the beagleboard. I assumed that reading the system timer would be no different. This was of course, not the case. For a beginner like myself, it was quite challenging to get it working on the bbxm.</summary></entry><entry><title type="html">Implementing TCP in Rust - Part 2</title><link href="/archive/implementing-tcp-in-rust-part2/" rel="alternate" type="text/html" title="Implementing TCP in Rust - Part 2" /><published>2022-04-16T00:00:00-07:00</published><updated>2022-04-16T00:00:00-07:00</updated><id>/archive/implementing-tcp-in-rust-part2</id><content type="html" xml:base="/archive/implementing-tcp-in-rust-part2/">&lt;p&gt;&lt;a href=&quot;https://arunvijayshankar.github.io/archive/implementing-tcp-in-rust/&quot;&gt;Part1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In my last &lt;a href=&quot;https://arunvijayshankar.github.io/archive/implementing-tcp-in-rust/&quot;&gt;post&lt;/a&gt; on @jonhoo’s live stream on implementing TCP in Rust, I covered everything upto the point where we parsed the source IP address, destination IP address, and payload length from the packet we received from a remote host. We emulated a remote host using a virtual interface, tun0, which we created using the TUN/TAP universal device driver. Picking up where we left off, in this post we explore the packet we received further, parse the TCP segment, and respond to the packet in a particular way, as is specified in &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc793&quot;&gt;RFC 793&lt;/a&gt;, the TCP functional specification document.&lt;/p&gt;

&lt;p&gt;As we are trying to implement TCP, we can try to make a TCP connection using netcat to any port:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nc 198.168.0.2 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We see that 40 bytes are received of protocol 6, which is TCP.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post3/formatted_packet_tcp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now that we have TCP packets, we can dive deeper into it, and go about actually implementing TCP. A good place to start that is RFC 793, which specifies the protocol in great detail. As an aside, it had never occurred to me to ask what it means to implement something like TCP. It simply means implement the expected behavior and rules as specified in the Standards document. For example, if the document says that a host (let’s say a server) that receives a SYN packet (which is a type of TCP segment, something we will go into detail in the next couple of posts) from a remote host (client), the server has to respond in a way that is specified in RFC 793. In the case of the SYN packet, the server can respond to the packet by either sending an ACK plus a SYN of it’s own, or choose to close the connection.&lt;/p&gt;

&lt;p&gt;To parse the TCP packets, we can use etherparse again. Another option is to write methods to parse the packets as well, but since most of the implementation of TCP has to do with bit manipulation, and not parsing, it is more convenient to let etherparse do all the heavy lifting here. With that out of the way, we can start with the actual details of the implementation. To begin with, there are two key objects we have to keep track of: the connection, which is identified by the source ip address, the source port, the destination ip address, and the destination port; and the state of the connection which can be either Listening, Closed, or Established, among others. The entire list of states can be found in RFC 793. We can store the the quad of values in the connection, and the state of the connection in structs, and have a hashmap from the quad to the state to hold all the connections.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#[derive(Clone, Copy, Debug, Hash, Eq, PartialEq)]
struct Quad { // This struct identifies each connection
    src: (Ipv4Addr, u16), // (&amp;lt;ip_addr&amp;gt;, &amp;lt;port&amp;gt;)
    dst: (Ipv4Addr, u16),
}

enum State { // enum to hold connection state value
    // Listen,
    SynRcvd,
    Estab,
    FinWait1,
    FinWait2,
    TimeWait,
}

pub struct Connection { // struct to hold the state of a particular connection [src ip, src port, dest ip, dest src]
    state: State,
    send: SendSequenceSpace,
    recv: RecvSequenceSpace,
    ip: etherparse::Ipv4Header,
    tcp: etherparse::TcpHeader,
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first thing to do when we receive a TCP segment is to make a connections entry for it. We store the src ip, src port, dest ip, and dest port in an instance of the Quad struct above, and check the hashmap if an entry exists for the connection. If one exists already, we have to deal with the packet. We implement this in a function called on_packet(). If there isn’t an entry in the hashmap for the connection, it is a new connection, and we will implement this functionality in a function called accept(). For now, we just print the quad values. When we run it now, we see all the data, and 0b of payload which indicates that it’s header only.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post4/formatted_packets_tcp_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To see exactly what the the packet we received looks like, we can run tshark again and then start a TCP connection.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post4/tshark_screen_shot.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that the first packet we received was a SYN packet. Having received it, we have to decide how we should respond. To do this, we can refer to RFC 793 and see what is to be done next. The entire process flow can be summarized in the following diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post4/proc_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A connection can be in CLOSED: meaning we do not reply if we are sent a packet, or LISTEN, meaning if someone we are not speaking to atm, sends a packet we are always going to deal with that packet. In our implementation we are going to assume that every port is listening. Exploring the diagram a bit, we see that if someone sends us a SYN, we can either close the connection, or we can send an ACK and a SYN ourself. I.e., we acknowledge the SYN that was sent, and send a SYN of our own asking if the remote machine wants to establish a connection. If we receive an ACK for our SYN, the connection is then established. If we wish to establish a connection, we start of at CLOSED, from where we go to OPEN, and then send a SYN. If the remote machine sends a SYN and ACK, we send an ACK and the connection is established. In our implementation, we implement the server part first, and the client part later. Since we are in server mode, we never send out any packets first.&lt;/p&gt;

&lt;p&gt;If a SYN packet is received, we need to handle that and start establishing a connection. Basically we have to write a TCP header. We can use etherparse again for this, which has a new() method to create a TCP segment. it takes a source port, destination port, sequence number and window size. We already know that source port for our TCP header is the destination port from the received SYN packet, and the destination port is the source port from the same packet. Sequence number and window size are something we have to figure out. As we are now responding to the SYN received from remote host, we have to send SYN and ACK, so we have to set those two bits in the header. This will have to be wrapped in an ipv4 header to send it back to the remote host. Again we can use etherparse to create the header for us (with new), and this takes payload length which is equal to length of the SYN/ACK msg, the timeout set to 64, the protocol, in this case TCP, source and destination addresses. Once done, this packet will now have to be sent out.&lt;/p&gt;

&lt;p&gt;I will stop here for this post. In my next post I will cover the part of the live stream that talks about writing TCP segments and IP packets, what fields are to be written, how they are calculated, and finally how to send them out to the “remote host” (the client, in this implementation).&lt;/p&gt;</content><author><name>Arun</name></author><category term="programming" /><category term="rust" /><category term="networking" /><summary type="html">Part1</summary></entry></feed>
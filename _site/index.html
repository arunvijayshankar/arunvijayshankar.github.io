<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Arktos kai Mennos</title>
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Arktos: | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Arktos:" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Arun Vijayshankar’s blog" />
<meta property="og:description" content="Arun Vijayshankar’s blog" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Arktos:" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"Arun Vijayshankar’s blog","headline":"Arktos:","name":"Arktos kai Mennos","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=66bc29320acc3ae14b63c41b3fba665155b48052">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


		
  			






		
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>

        <nav>
        <ul class="nav-links">
        <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
        </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        
        
	 
        <h2>Tags</h2>



  
  
  <a href="/tag/programming"><nobr>programming</nobr></a>

  
  
  <a href="/tag/networking"><nobr>networking</nobr></a>

  
  
  <a href="/tag/rust"><nobr>rust</nobr></a>

  
  
  <a href="/tag/python"><nobr>python</nobr></a>

  
  
  <a href="/tag/vpn"><nobr>vpn</nobr></a>

  
  
  <a href="/tag/ssh"><nobr>ssh</nobr></a>



        
      </header>


      <section>

      <h2 id="arktos">Arktos:</h2>
<p>Ancient Greek: Bear</p>

<h2 id="mennos">Mennos:</h2>
<p>Ancient Greek (Aeolic): Moon</p>



      </section>
      

      
        <!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Implementing TCP in Rust - Part 2 - Arktos kai Mennos</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Implementing TCP in Rust - Part 2 | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Implementing TCP in Rust - Part 2" />
<meta name="author" content="Arun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Part1" />
<meta property="og:description" content="Part1" />
<link rel="canonical" href="http://localhost:4000/archive/implementing-tcp-in-rust-part2/" />
<meta property="og:url" content="http://localhost:4000/archive/implementing-tcp-in-rust-part2/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-04-16T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Implementing TCP in Rust - Part 2" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arun"},"dateModified":"2022-04-16T00:00:00-07:00","datePublished":"2022-04-16T00:00:00-07:00","description":"Part1","headline":"Implementing TCP in Rust - Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archive/implementing-tcp-in-rust-part2/"},"url":"http://localhost:4000/archive/implementing-tcp-in-rust-part2/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=66bc29320acc3ae14b63c41b3fba665155b48052">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>
        <nav>
          <ul class="nav-links">
          <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
          </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        

        
        
        
      </header>
      <section>

      
<div class="post">

  <h1 class="post-title">Implementing TCP in Rust - Part 2</h1>
  Published on <span class="post-date">16 Apr 2022</span>, under: 
  <span class="post-tags">
    &nbsp;|
    
      
      <a class="no-underline" href="/tag/programming"><nobr> programming |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/rust"><nobr> rust |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/networking"><nobr> networking |</nobr>&nbsp;</a>    
    
    &nbsp;
  </span>
  <p></p>
  <p><a href="https://arunvijayshankar.github.io/archive/implementing-tcp-in-rust/">Part1</a></p>

<p>In my last <a href="https://arunvijayshankar.github.io/archive/implementing-tcp-in-rust/">post</a> on @jonhoo’s live stream on implementing TCP in Rust, I covered everything upto the point where we parsed the source IP address, destination IP address, and payload length from the packet we received from a remote host. We emulated a remote host using a virtual interface, tun0, which we created using the TUN/TAP universal device driver. Picking up where we left off, in this post we explore the packet we received further, parse the TCP segment, and respond to the packet in a particular way, as is specified in <a href="https://datatracker.ietf.org/doc/html/rfc793">RFC 793</a>, the TCP functional specification document.</p>

<p>As we are trying to implement TCP, we can try to make a TCP connection using netcat to any port:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc 198.168.0.2 80
</code></pre></div></div>

<p>We see that 40 bytes are received of protocol 6, which is TCP.</p>

<p><img src="/assets/images/post3/formatted_packet_tcp.png" alt="" /></p>

<p>Now that we have TCP packets, we can dive deeper into it, and go about actually implementing TCP. A good place to start that is RFC 793, which specifies the protocol in great detail. As an aside, it had never occurred to me to ask what it means to implement something like TCP. It simply means implement the expected behavior and rules as specified in the Standards document. For example, if the document says that a host (let’s say a server) that receives a SYN packet (which is a type of TCP segment, something we will go into detail in the next couple of posts) from a remote host (client), the server has to respond in a way that is specified in RFC 793. In the case of the SYN packet, the server can respond to the packet by either sending an ACK plus a SYN of it’s own, or choose to close the connection.</p>

<p>To parse the TCP packets, we can use etherparse again. Another option is to write methods to parse the packets as well, but since most of the implementation of TCP has to do with bit manipulation, and not parsing, it is more convenient to let etherparse do all the heavy lifting here. With that out of the way, we can start with the actual details of the implementation. To begin with, there are two key objects we have to keep track of: the connection, which is identified by the source ip address, the source port, the destination ip address, and the destination port; and the state of the connection which can be either Listening, Closed, or Established, among others. The entire list of states can be found in RFC 793. We can store the the quad of values in the connection, and the state of the connection in structs, and have a hashmap from the quad to the state to hold all the connections.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#[derive(Clone, Copy, Debug, Hash, Eq, PartialEq)]
struct Quad { // This struct identifies each connection
    src: (Ipv4Addr, u16), // (&lt;ip_addr&gt;, &lt;port&gt;)
    dst: (Ipv4Addr, u16),
}

enum State { // enum to hold connection state value
    // Listen,
    SynRcvd,
    Estab,
    FinWait1,
    FinWait2,
    TimeWait,
}

pub struct Connection { // struct to hold the state of a particular connection [src ip, src port, dest ip, dest src]
    state: State,
    send: SendSequenceSpace,
    recv: RecvSequenceSpace,
    ip: etherparse::Ipv4Header,
    tcp: etherparse::TcpHeader,
}

</code></pre></div></div>

<p>The first thing to do when we receive a TCP segment is to make a connections entry for it. We store the src ip, src port, dest ip, and dest port in an instance of the Quad struct above, and check the hashmap if an entry exists for the connection. If one exists already, we have to deal with the packet. We implement this in a function called on_packet(). If there isn’t an entry in the hashmap for the connection, it is a new connection, and we will implement this functionality in a function called accept(). For now, we just print the quad values. When we run it now, we see all the data, and 0b of payload which indicates that it’s header only.</p>

<p><img src="/assets/images/post4/formatted_packets_tcp_3.png" alt="" /></p>

<p>To see exactly what the the packet we received looks like, we can run tshark again and then start a TCP connection.</p>

<p><img src="/assets/images/post4/tshark_screen_shot.png" alt="" /></p>

<p>We can see that the first packet we received was a SYN packet. Having received it, we have to decide how we should respond. To do this, we can refer to RFC 793 and see what is to be done next. The entire process flow can be summarized in the following diagram:</p>

<p><img src="/assets/images/post4/proc_flow.png" alt="" /></p>

<p>A connection can be in CLOSED: meaning we do not reply if we are sent a packet, or LISTEN, meaning if someone we are not speaking to atm, sends a packet we are always going to deal with that packet. In our implementation we are going to assume that every port is listening. Exploring the diagram a bit, we see that if someone sends us a SYN, we can either close the connection, or we can send an ACK and a SYN ourself. I.e., we acknowledge the SYN that was sent, and send a SYN of our own asking if the remote machine wants to establish a connection. If we receive an ACK for our SYN, the connection is then established. If we wish to establish a connection, we start of at CLOSED, from where we go to OPEN, and then send a SYN. If the remote machine sends a SYN and ACK, we send an ACK and the connection is established. In our implementation, we implement the server part first, and the client part later. Since we are in server mode, we never send out any packets first.</p>

<p>If a SYN packet is received, we need to handle that and start establishing a connection. Basically we have to write a TCP header. We can use etherparse again for this, which has a new() method to create a TCP segment. it takes a source port, destination port, sequence number and window size. We already know that source port for our TCP header is the destination port from the received SYN packet, and the destination port is the source port from the same packet. Sequence number and window size are something we have to figure out. As we are now responding to the SYN received from remote host, we have to send SYN and ACK, so we have to set those two bits in the header. This will have to be wrapped in an ipv4 header to send it back to the remote host. Again we can use etherparse to create the header for us (with new), and this takes payload length which is equal to length of the SYN/ACK msg, the timeout set to 64, the protocol, in this case TCP, source and destination addresses. Once done, this packet will now have to be sent out.</p>

<p>I will stop here for this post. In my next post I will cover the part of the live stream that talks about writing TCP segments and IP packets, what fields are to be written, how they are calculated, and finally how to send them out to the “remote host” (the client, in this implementation).</p>

</div>

      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

      
        <!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SSH over an OpenVPN connection - Arktos kai Mennos</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>SSH over an OpenVPN connection | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="SSH over an OpenVPN connection" />
<meta name="author" content="Arun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TL;DR" />
<meta property="og:description" content="TL;DR" />
<link rel="canonical" href="http://localhost:4000/archive/ssh-over-an-openvpn-connection/" />
<meta property="og:url" content="http://localhost:4000/archive/ssh-over-an-openvpn-connection/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-04-02T10:45:16-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SSH over an OpenVPN connection" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arun"},"dateModified":"2022-04-02T10:45:16-07:00","datePublished":"2022-04-02T10:45:16-07:00","description":"TL;DR","headline":"SSH over an OpenVPN connection","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archive/ssh-over-an-openvpn-connection/"},"url":"http://localhost:4000/archive/ssh-over-an-openvpn-connection/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=66bc29320acc3ae14b63c41b3fba665155b48052">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>
        <nav>
          <ul class="nav-links">
          <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
          </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        

        
        
        
      </header>
      <section>

      
<div class="post">

  <h1 class="post-title">SSH over an OpenVPN connection</h1>
  Published on <span class="post-date">02 Apr 2022</span>, under: 
  <span class="post-tags">
    &nbsp;|
    
      
      <a class="no-underline" href="/tag/networking"><nobr> networking |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/ssh"><nobr> ssh |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/vpn"><nobr> vpn |</nobr>&nbsp;</a>    
    
    &nbsp;
  </span>
  <p></p>
  <p><em>TL;DR</em></p>

<p>If you have an active OpenVPN connection to a remote linux machine, and are finding that you cannot ssh to it, try setting up port forwarding on your router config page to forward traffic from the OpenVPN port to the ssh port on your box. Configure the device IP on the config page to point to the local ip address of the linux machine. Connect over ssh with: <em>ssh host@local_ip_address</em></p>

<p><em>/TL;DR</em></p>

<p>About two years ago I bought a cheap desktop computer and installed Linux (Ubuntu, because I’m a noob) on it. I decided that I wanted to learn software development, and I wanted to do it on Linux. Setup was not without issues, and I still haven’t managed to get wifi working on it, but overall it was easy. I thought I would use the box for learning and writing code only, but it has become my primary home PC. I’m using it right now in writing this. The PC serves me very well, but almost immediately after setting it up, I realized I wanted to ssh into it from a remote host. Mainly from my laptop for when I work from bed.</p>

<p>I looked up how to get ssh running on ubuntu and found lots of great guides on the topic. I configured the server, and added key based authentication for extra security. This was super easy and I was able to ssh into the linux box from my laptop. But because I am greedy, I wanted to be able to ssh into from outside my home network too. I looked up how to do that and when I saw that it meant I had to expose the ssh port to the internet at large, I was sufficiently put off to abandon the idea altogether. It also seemed to involve something called “port forwarding” which I don’t think I will ever truly understand. If anyone reading this post has any resources that explain port forwarding in a easy to understand fashion, I would appreciate it if you could send it my way.</p>

<p>Now that I am a little older, and with about the same amount of wisdom, I decided to take another stab at it. Having worked from home for the past two years, and having acquired a better understanding of what VPNs are and how they work, I wondered if I could set up a home VPN and connect to that remotely. If I could do that, then I could ssh into the linux box from anywhere. Easy-peasy. After a bit of reading, I learnt that you can setup a VPN using your home router. I checked mine and found that it could setup a VPN. Mine has a couple of options for VPNs, but I choose OpenVPN becuase I had heard of it and becuase it said “secure” in the description. I intend to look into PPTP and L2TP/IPSec (the other options) a little later. I configured OpenVPN by following the online guide published for TP-Link routers. Configuring it on your router might be a little different. Searching for <em>router_name VPN setup</em> should return setup guides for your router, if you wish to set one up. I also downloaded and installed the OpenVPN client on my laptop. I configured the client with the OpenVPN config file I generated on the Linux box (which is now the OpenVPN server).</p>

<p>With all of this setup, I connected my laptop to a mobile hotspot using my phone to simulate an external network and tried to connect to the VPN. After a little bit of fiddling around with the server settings, I could connect to it. I tried pinging the server, and once I confirmed that it was working, I tried to connect over ssh. Which did not work. Server was rejecting my connections. So I went back to the internet. I found that while this is not a very common issue, it has been faced by quite a few people. The common diagnosis was that all traffic gets tunneled over the VPN, and we have to let the server know to deal with SSH traffic separately. Most fixes I read involved changing the ip table rules to do… something. I can’t say I understood what that was all about. Still, in true sw engineer fashion, I tried out the commands to edit the ip table. This did not work either, as the syntax for editing the ip table has either changed, or is different for ubuntu for some reason.</p>

<p>I did find one post that specified allowing ssh over the OpenVPN port (which was configured when I set OpenVPN up) through the firewall. That seemed promising, so I tried it out. Still no luck. The server kept rejecting my ssh connections. I was about to give up once again, when I remembered one particular comment in one of the posts which suggested setting up NAT forwarding. I was still reluctant to try changing anything here, since, as mentioned earlier, I don’t really understand what port forwarding is. However, since I was grasping at straws at this point, I thought I’d give it a shot. And there it was, in the NAT forwarding tab in my router config page: “Port Forwarding”. The config page asked me to specify a device IP address, an internal port, and an external port. At first I tried the ssh port for both internal and external ports, which did not work at all. Then I realised that the external port was the port to which traffic was being sent, and the internal port was the port to which traffic was to be forwarded. The device IP address was to be set to the IP address of the device to which the traffic was to be forwarded. This became clear once I realized that when I connect to a VPN, I am essentially making a connection to my router, and not necessarily to any device on my home network. With port forwarding configured and enabled, I was able to ssh to my linux box from my laptop! I headed over to a cafe to try it out from an actual public networked and it worked there as well.</p>

<p>It seems a little unbelievable that I have finally managed to solve something that I have been unsuccessful at on so many attempts in the past two years. I guess the lesson is, if a problem is being difficult, set it aside and try again at a different time. You might have learned something that turns to be the key to solving it.</p>

<p><em>PS</em></p>

<p>An interesting aside: I can ssh over the VPN if I use the IP address on my home subnet, but not when I use the IP address provided to the box by OpenVPN. I’m guessing that this is because I provided the home subnet IP address when I configured port forwarding on the router. But if I try and configure the OpenVPN IP address for port forwarding, the router rejects it, saying that it should have the same netmask as the router. Not sure if I can get around this. If anyone knows any way to ssh over OpenVPN with the IP address assigned by OpenVPN, please let me know!</p>

</div>

      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

      
        <!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Implementing TCP in Rust - Arktos kai Mennos</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Implementing TCP in Rust | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Implementing TCP in Rust" />
<meta name="author" content="Arun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="One good thing about TwitterTM is that once in a while I come across a tweet that voices out load the exact thing I was looking for. In this instance, I found this tweet from @b0rk, looking for networking courses. There were a lot of good suggestions, but this one caught my eye: Implementing TCP, by @jonhoo. It is an implementation of TCP using Rust. It drew my eye immediately as learning Rust has been on my mind for a while now. Now, I do not know the first thing about Rust, and not very much more about networking, but I have found that I learn best by doing, so I drove right into it. Jon mentions RFC 1180 as a good tutorial to TCP/IP which I started reading in parallel to the video series. I’m about 45 minutes into Part 1, and there are already a bunch of concepts with which I am completely unfamiliar. Nevertheless, just by following along, I was able to write a “virtual” NIC in rust. The only thing it does is read an IP packet as a bunch of bytes. Still, pretty cool. It wasn’t without hicups though. The setcap command did not work until I provided the entire path to the compiled binary, and for some reason $CARGO_TARGET_DIR, which I assumed was set during the setup, was not really set to anything. But barring these minor setbacks, the code compiled and ran pretty well." />
<meta property="og:description" content="One good thing about TwitterTM is that once in a while I come across a tweet that voices out load the exact thing I was looking for. In this instance, I found this tweet from @b0rk, looking for networking courses. There were a lot of good suggestions, but this one caught my eye: Implementing TCP, by @jonhoo. It is an implementation of TCP using Rust. It drew my eye immediately as learning Rust has been on my mind for a while now. Now, I do not know the first thing about Rust, and not very much more about networking, but I have found that I learn best by doing, so I drove right into it. Jon mentions RFC 1180 as a good tutorial to TCP/IP which I started reading in parallel to the video series. I’m about 45 minutes into Part 1, and there are already a bunch of concepts with which I am completely unfamiliar. Nevertheless, just by following along, I was able to write a “virtual” NIC in rust. The only thing it does is read an IP packet as a bunch of bytes. Still, pretty cool. It wasn’t without hicups though. The setcap command did not work until I provided the entire path to the compiled binary, and for some reason $CARGO_TARGET_DIR, which I assumed was set during the setup, was not really set to anything. But barring these minor setbacks, the code compiled and ran pretty well." />
<link rel="canonical" href="http://localhost:4000/archive/implementing-tcp-in-rust/" />
<meta property="og:url" content="http://localhost:4000/archive/implementing-tcp-in-rust/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-25T15:19:50-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Implementing TCP in Rust" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arun"},"dateModified":"2022-03-25T15:19:50-07:00","datePublished":"2022-03-25T15:19:50-07:00","description":"One good thing about TwitterTM is that once in a while I come across a tweet that voices out load the exact thing I was looking for. In this instance, I found this tweet from @b0rk, looking for networking courses. There were a lot of good suggestions, but this one caught my eye: Implementing TCP, by @jonhoo. It is an implementation of TCP using Rust. It drew my eye immediately as learning Rust has been on my mind for a while now. Now, I do not know the first thing about Rust, and not very much more about networking, but I have found that I learn best by doing, so I drove right into it. Jon mentions RFC 1180 as a good tutorial to TCP/IP which I started reading in parallel to the video series. I’m about 45 minutes into Part 1, and there are already a bunch of concepts with which I am completely unfamiliar. Nevertheless, just by following along, I was able to write a “virtual” NIC in rust. The only thing it does is read an IP packet as a bunch of bytes. Still, pretty cool. It wasn’t without hicups though. The setcap command did not work until I provided the entire path to the compiled binary, and for some reason $CARGO_TARGET_DIR, which I assumed was set during the setup, was not really set to anything. But barring these minor setbacks, the code compiled and ran pretty well.","headline":"Implementing TCP in Rust","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archive/implementing-tcp-in-rust/"},"url":"http://localhost:4000/archive/implementing-tcp-in-rust/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=66bc29320acc3ae14b63c41b3fba665155b48052">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>
        <nav>
          <ul class="nav-links">
          <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
          </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        

        
        
        
      </header>
      <section>

      
<div class="post">

  <h1 class="post-title">Implementing TCP in Rust</h1>
  Published on <span class="post-date">25 Mar 2022</span>, under: 
  <span class="post-tags">
    &nbsp;|
    
      
      <a class="no-underline" href="/tag/programming"><nobr> programming |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/rust"><nobr> rust |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/networking"><nobr> networking |</nobr>&nbsp;</a>    
    
    &nbsp;
  </span>
  <p></p>
  <p>One good thing about Twitter<sup>TM</sup> is that once in a while I come across a tweet that voices out load the exact thing I was looking for. In this instance, I found this <a href="https://twitter.com/b0rk/status/1505597582227165194">tweet</a> from <a href="https://twitter.com/b0rk">@b0rk</a>, looking for networking courses. There were a lot of good suggestions, but this one caught my eye: <a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFivDY3iKAQk3_VAm8SXwt1X">Implementing TCP</a>, by <a href="https://twitter.com/jonhoo">@jonhoo</a>. It is an implementation of TCP using Rust. It drew my eye immediately as learning Rust has been on my mind for a while now. Now, I do not know the first thing about Rust, and not very much more about networking, but I have found that I learn best by doing, so I drove right into it. Jon mentions RFC 1180 as a good tutorial to TCP/IP which I started reading  in parallel to the video series. I’m about 45 minutes into Part 1, and there are already a bunch of concepts with which I am completely unfamiliar. Nevertheless, just by following along, I was able to write a “virtual” NIC in rust. The only thing it does is read an IP packet as a bunch of bytes. Still, pretty cool. It wasn’t without hicups though. The setcap command did not work until I provided the entire path to the compiled binary, and for some reason $CARGO_TARGET_DIR, which I assumed was set during the setup, was not really set to anything. But barring these minor setbacks, the code compiled and ran pretty well.</p>

<p><img src="/assets/images/post3/ip_packet_rcvd_1.png" alt="" /></p>

<p>The first new rust concept i hit upon in the video was cargo. Cargo is the build and packaging system of Rust. I learned that it downloads the necessary libraries and builds your code. You list your projects dependencies (packages of code, called Crates) in the .toml file, and Cargo will download and link them for you. You can use cargo to build your code using “cargo build –release” and it will build and create your binaries in a separate folder. There are a bunch of options you can specify in the build command like ‘r’ to build your code, and then run it, or ‘b’ to only compile your code and build the binary.</p>

<p>The tutorial introduced TUN/TAP next. This is a really cool kernel module that provides packet transmission and reception for User space programs. If I understand correctly, it creates a virtual network adapter to whom the kernel forwards packets from a user space program, and whose packets the kernel sends to the user space program. There is already a Rust crate for Tun/Tap bindings which is used in the tutorial. It’s a really cool module, and I’m sure I’ll be using it a lot in my networking adventures in the future. The actual syntax is very similar to C and Jon quickly covered the actual code by following the tun_tap docs closely.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
use std::io;

fn main() -&gt; io::Result&lt;()&gt; {
	let nic = tun_tap::Iface::new("tun0", tun_tap::Mode::Tun)?;
	let mut buf = [0u8; 1504];
	let nbytes = nic.recv(&amp;mut buf[..])?;
	eprintln!("read {} bytes: {:x?}", nbytes, &amp;buf[..nbytes]);
	Ok(())
}

</code></pre></div></div>

<p>A new thing in Rust is the syntax to use library functions. For example, to user a function called “some_function()” that is part of “some_library”, you would write: some_library::some_function(). A few other new things are “match”, OK(), Err(), and the “-&gt;” and “=&gt;” operators, but I will dive deeper into them as I move forward.</p>

<p>To use TUN/TAP, we need CAP_NET_ADMIN privileges which is confirgured with the setcap command: <code class="language-plaintext highlighter-rouge">sudo setcap cap_net_admin=eip &lt;path_to_target&gt;</code>. The tutorial uses $CARGO_TARGET_DIR in the path, but for some reason this did not work for me. I am not really sure if I have to set this variable myself, or if it gets set by cargo. In any case I was able to get around this by simply providing the relative path to the target. Finally, we compiled the code and ran it. Now when you run <code class="language-plaintext highlighter-rouge">ip addr</code>, you can see tun0 show up in your list of network devices.</p>

<p><img src="/assets/images/post3/tun0_offline.png" alt="" /></p>

<p>As of now, tun0 is not really doing anything. To configure it to listen for IP packets we have to run the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sudo ip addr add &lt;some IP address&gt; dev tun0

sudo ip link set up dev tun0

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">"ip addr add &lt;static IP address&gt; dev &lt;device name&gt;"</code> adds an ip address to the newly created network device tun0, and once that’s done, we bring tun0 online with <code class="language-plaintext highlighter-rouge">"ip link set up dev &lt;device name&gt;"</code>. tun0 will now listen for IP packets and the code will display the bytes in the packet that tun0 received.</p>

<p><img src="/assets/images/post3/tun0_online.png" alt="" /></p>

<p>To simplify the whole process, all the individual commands were wrapped up in a shell file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;#!/bin/bash
cargo b --release
sudo setcap cap_net_admin=eip &lt;path to binary&gt;
&lt;path to binary&gt; &amp;
pid=$!
sudo ip addr add 192.168.0.1/24 dev tun0
sudo ip link set up dev tun0
trap "kill $pid" INT TERM
wait $pid

</code></pre></div></div>

<p>and anytime we want trust to listen for IP packets sent to tun0, we can run the .sh file to compile any changes to the code, set cap_net_admin, run the program, and bring tun0 online.</p>

<p>So now we can bring tun0 online and listen for packets, but the program will stop running once tun0 receives an IP packet. To keep tun0 listening indefinitely, we put it in a loop. Loop is a rust functionality that let’s you run an infinite loop. Just put your code in a block like so</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
loop {

	# code goes here

}

</code></pre></div></div>

<p>Now we can ping the IP address we set earlier, and the component bytes will be displayed consecutively. However, these bytes are not really readable to most of us, I would imagine. To make better sense of the data, a rust crate called etherparse can be used to parse the hex data and extract useful information from them. We choose to pull source IP, destination IP, payload length, and IP protocol.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
match etherparse::Ipv4HeaderSlice::from_slice(&amp;buf[4..nbytes]) {
	Ok(p) =&gt; {
		let src = p.source_addr();
		let dst = p.destination_addr();
		let protocol = p.protocol();
		eprintln!(
			"{} -&gt; {} {}b of protocol {}",
			src,
			dst,
			p.payload_len(),
			protocol
		);
	},
	Err(e) =&gt; {
		eprintln!("ignoring weird packet {:?}", e);
	}
}

</code></pre></div></div>

<p>When we run the wrapper, we see a nicely formatted, more informational strings:</p>

<p><img src="/assets/images/post3/formatted_packets_ping.png" alt="" /></p>

<p>We can see that packets were sent to 192.168.0.2 from 192.168.0.1 with IP protocol 1, which is ICMP which is what ping uses. We can also use netcap to try and connect to the IP address (at any port) to see if it is reflected correctly:</p>

<p><img src="/assets/images/post3/formatted_packet_tcp.png" alt="" /></p>

<p>We can see that 40 bytes are received of protocol 6, which is TCP.</p>

<p>This brings us to the end of the first 45 minutes of the tutorial. I will cover the rest of the tutorial in roughly one hour chunks, I think. Along with actually coding and ironing out issues, it takes me around an hour or so to get through 45 minutes of video, so it seems like a good duration. The tutorial is 13 hours in total, and I expect to complete it in a month or so. Ideally, I would like to finish it a lot sooner, but needs must, so 45 minutes at a time it will have to be.</p>


</div>

      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

      

      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KLNXCRJB2P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KLNXCRJB2P');
</script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Arktos kai Mennos</title>
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Arktos: | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Arktos:" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Arun Vijayshankar’s blog" />
<meta property="og:description" content="Arun Vijayshankar’s blog" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Arktos:" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"Arun Vijayshankar’s blog","headline":"Arktos:","name":"Arktos kai Mennos","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=e175cf2cc7de7cf31d60056b73775779ae8b25c7">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


		
  			






		
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>

        <nav>
        <ul class="nav-links">
        <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
        </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        
        
	 
        <h2>Tags</h2>



  
  
  <a href="/tag/programming"><nobr>programming</nobr></a>

  
  
  <a href="/tag/networking"><nobr>networking</nobr></a>

  
  
  <a href="/tag/rust"><nobr>rust</nobr></a>

  
  
  <a href="/tag/python"><nobr>python</nobr></a>

  
  
  <a href="/tag/embedded"><nobr>embedded</nobr></a>

  
  
  <a href="/tag/cpp"><nobr>cpp</nobr></a>

  
  
  <a href="/tag/c"><nobr>c</nobr></a>

  
  
  <a href="/tag/vpn"><nobr>vpn</nobr></a>

  
  
  <a href="/tag/ssh"><nobr>ssh</nobr></a>

  
  
  <a href="/tag/linux"><nobr>linux</nobr></a>

  
  
  <a href="/tag/device-drivers"><nobr>device-drivers</nobr></a>



        
      </header>


      <section>

      <h2 id="arktos">Arktos:</h2>
<p>Ancient Greek: Bear</p>

<h2 id="mennos">Mennos:</h2>
<p>Ancient Greek (Aeolic): Moon</p>



      </section>
      

      
        <!DOCTYPE html>
<html lang="en-US">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KLNXCRJB2P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KLNXCRJB2P');
</script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>What is scull - Arktos kai Mennos</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>What is scull | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="What is scull" />
<meta name="author" content="Arun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Scull: Simple Character Utility for Loading Localities" />
<meta property="og:description" content="Scull: Simple Character Utility for Loading Localities" />
<link rel="canonical" href="http://localhost:4000/archive/what-is-scull/" />
<meta property="og:url" content="http://localhost:4000/archive/what-is-scull/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-06T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="What is scull" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arun"},"dateModified":"2022-07-06T00:00:00-07:00","datePublished":"2022-07-06T00:00:00-07:00","description":"Scull: Simple Character Utility for Loading Localities","headline":"What is scull","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archive/what-is-scull/"},"url":"http://localhost:4000/archive/what-is-scull/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=e175cf2cc7de7cf31d60056b73775779ae8b25c7">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>
        <nav>
          <ul class="nav-links">
          <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
          </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        

        <h2>Tags</h2>



  
  
  <a href="/tag/programming"><nobr>programming</nobr></a>

  
  
  <a href="/tag/networking"><nobr>networking</nobr></a>

  
  
  <a href="/tag/rust"><nobr>rust</nobr></a>

  
  
  <a href="/tag/python"><nobr>python</nobr></a>

  
  
  <a href="/tag/embedded"><nobr>embedded</nobr></a>

  
  
  <a href="/tag/cpp"><nobr>cpp</nobr></a>

  
  
  <a href="/tag/c"><nobr>c</nobr></a>

  
  
  <a href="/tag/vpn"><nobr>vpn</nobr></a>

  
  
  <a href="/tag/ssh"><nobr>ssh</nobr></a>

  
  
  <a href="/tag/linux"><nobr>linux</nobr></a>

  
  
  <a href="/tag/device-drivers"><nobr>device-drivers</nobr></a>


        
        
        
      </header>
      <section>

      
<div class="post">

  <h1 class="post-title">What is scull</h1>
  Published on <span class="post-date">06 Jul 2022</span>, under: 
  <span class="post-tags">
    &nbsp;|
    
      
      <a class="no-underline" href="/tag/programming"><nobr> programming |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/c"><nobr> c |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/linux"><nobr> linux |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/device-drivers"><nobr> device-drivers |</nobr>&nbsp;</a>    
    
    &nbsp;
  </span>
  <p></p>
  <h2 id="scull-simple-character-utility-for-loading-localities">Scull: Simple Character Utility for Loading Localities</h2>

<p>“scull is char driver that acts on a memory area as though it were a device.”, is how scull is described in chapter 3 of 
<a href="https://lwn.net/Kernel/LDD3/">Linux Device Drivers</a>. That seemed straightforward enough. Scull’s capabilities and allowed operations are described
in detail in the rest of the chapter. Once I finished the chapter, I wanted to learn more about what exactly scull was, and how I could go about
using it. But there seems to be surprisingly little information about it online. I thought I’d write a little something about what I have learned about 
it so far.</p>

<p>Scull, if I understand it correctly, is fundamentally a kernel module. When the module is loaded, using insmod or modprobe, the kernel allocates some 
memory for scull, which then treats that memory region like a character device. Once loaded, scull will show up in /proc/devices:</p>

<p><img src="/assets/images/post8/proc_devices.png" alt="" /></p>

<p>A user can then use it as they would a regular character device. One can open and close it, read from it, or write to it.</p>

<p>The source code for scull can be found <a href="http://gauss.ececs.uc.edu/Courses/c4029/code/drivers/Scull/scull.html">here</a>. It can be compiled as a module 
by extracting the files from that archive and running <code class="language-plaintext highlighter-rouge">make</code> at the source directory. Loading and Unloading of the module can be done using scull.load 
and scull.unload respectively. The shell scripts also clean up stale filesystem nodes, and setup new ones after loading the module. The newly created 
nodes will now show up under /dev:</p>

<p><img src="/assets/images/post8/ls_dev.png" alt="" /></p>

<h2 id="device-types-and-supported-operations">Device types and supported operations</h2>

<p>Scull supports different types of devices:</p>
<ul>
  <li>scull0 - scull3
    <ul>
      <li>These are global and persistant, meaning the data stored in them is shared between all the open file descriptors associated with it, and that the data is not lost if a file descriptor is closed.</li>
    </ul>
  </li>
  <li>scullpipe0 - scullpipe3
    <ul>
      <li>These are FIFO devices which act as pipes.</li>
    </ul>
  </li>
  <li>scullsingle, scullpriv, sculluid, scullwuid
    <ul>
      <li>These are similar to scull0, with limitations on when open can be called on them.</li>
    </ul>
  </li>
</ul>

<p>Scull implements the following basic device methods:</p>
<ul>
  <li>llseek():     Change current read/write position in a file.</li>
  <li>read():       Retrieve data from the device.</li>
  <li>write():      Write data to the device.</li>
  <li>open():       First operation performed on the file.</li>
  <li>ioctl():      Issue device specific commands, which are neither reading or writing.</li>
  <li>release():    Invoked when file structure is released.</li>
</ul>

<h2 id="using-scull">Using scull</h2>

<p>To use scull, we have have to first compile it to create scull module. The Makefile in the distribution comes configured, so all that needs to be done
is to run <code class="language-plaintext highlighter-rouge">sudo make</code> from the source directory<sup>*</sup>. You would need a machine running a linux kernel to compile it successfully, I’m pretty sure. Once the module is compiled and ready to be loaded, run the scull.load bash script to load the module, and create the filesystem nodes.</p>

<p>The scull device is now ready to be written to, and read from. The scull distribution comes with a test file: sculltest.c</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* sculltest.c
 * A simple example of a C program to test some of the
 * operations of the "/dev/scull" device (a.k.a "scull0"),
 * and the 
 * ($Id: sculltest.c,v 1.1 2010/05/19 20:40:00 baker Exp baker $)
 */
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;

int main() {
   int fd, result, len;
   char buf[10];
   const char *str;
   if ((fd = open("/dev/scull", O_WRONLY)) == -1) {
      perror("1. open failed");
      return -1;
   }

   str = "abcde"; 
   len = strlen(str);
   if ((result = write(fd, str, len)) != len) {
      perror("1. write failed");
      return -1;
   }
   close(fd);

   if ((fd = open("/dev/scull", O_RDONLY)) == -1) {
      perror("2. open failed");
      return -1;
   }
   if ((result = read(fd, &amp;buf, sizeof(buf))) != len) {
      fprintf(stdout, "1. read failed, buf=%s",buf);
      return -1;
   } 
   buf[result] = '\0';
   if (strncmp (buf, str, len)) {
      fprintf (stdout, "failed: read back \"%s\"\n", buf);
   } else {
      fprintf (stdout, "passed\n");
   }
   close(fd);

   ---SNIP---
</code></pre></div></div>
<p>Once the module is loaded, sculltest.c can be compiled and run to test out open, read, and write. Upon a read or write syscall, the corresponding 
function implemented in scull is called. The user can of course, write their own tests to test out supported operations.</p>

<p>To gain a better understanding of scull and char drivers in general, I implemented a minimalistic version that supports only basic open/close, read/write operations, and only supports the global, persistant scull device type (scull0 - scull3). It can be found <a href="https://github.com/arunvijayshankar/vichy">here</a>. The other major difference is the memory layout. In scull, each device is a linked list of structures, each of which points to a memory area of 4MB at most, though an array of a 1000 pointers, each pointing to a memory area of 4000 bytes. In vichy, each structure in the linked list making up the device points to just one memory area of 4000 bytes. These changes necessitated a few changes in the actual code, but they are small and cosmetic. Which is ok, I think. As a learner, it is a good confidence boost to make small changes to a project and learn by debugging all the issues you run into. This way you can learn the technology, and gain some actual coding experience.</p>

<p><sup>*</sup>Note: On newer kernels (I’m running 5.19.0-rc3), scull hits compilations errors, mostly due to a depracated method. The errors can be fixed with these patches</p>
<ul>
  <li>main.c: https://gist.github.com/arunvijayshankar/213e4dc0442ad3f4cd2b9785abc878a7</li>
  <li>pipe.c: https://gist.github.com/arunvijayshankar/1cd5a2672fe540e196e9c27d163b0407</li>
  <li>access.c: https://gist.github.com/arunvijayshankar/ae12566ac20707eb43afdf3e3d05a570</li>
</ul>

</div>

      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

      
        <!DOCTYPE html>
<html lang="en-US">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KLNXCRJB2P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KLNXCRJB2P');
</script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Cross Compiling for BeagleBoard targets, and benchmarks - Arktos kai Mennos</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Cross Compiling for BeagleBoard targets, and benchmarks | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Cross Compiling for BeagleBoard targets, and benchmarks" />
<meta name="author" content="Arun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:" />
<meta property="og:description" content="I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:" />
<link rel="canonical" href="http://localhost:4000/archive/cross-compiling-for-beagleboard-and-benchmarks/" />
<meta property="og:url" content="http://localhost:4000/archive/cross-compiling-for-beagleboard-and-benchmarks/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-30T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Cross Compiling for BeagleBoard targets, and benchmarks" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arun"},"dateModified":"2022-06-30T00:00:00-07:00","datePublished":"2022-06-30T00:00:00-07:00","description":"I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:","headline":"Cross Compiling for BeagleBoard targets, and benchmarks","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archive/cross-compiling-for-beagleboard-and-benchmarks/"},"url":"http://localhost:4000/archive/cross-compiling-for-beagleboard-and-benchmarks/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=e175cf2cc7de7cf31d60056b73775779ae8b25c7">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>
        <nav>
          <ul class="nav-links">
          <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
          </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        

        <h2>Tags</h2>



  
  
  <a href="/tag/programming"><nobr>programming</nobr></a>

  
  
  <a href="/tag/networking"><nobr>networking</nobr></a>

  
  
  <a href="/tag/rust"><nobr>rust</nobr></a>

  
  
  <a href="/tag/python"><nobr>python</nobr></a>

  
  
  <a href="/tag/embedded"><nobr>embedded</nobr></a>

  
  
  <a href="/tag/cpp"><nobr>cpp</nobr></a>

  
  
  <a href="/tag/c"><nobr>c</nobr></a>

  
  
  <a href="/tag/vpn"><nobr>vpn</nobr></a>

  
  
  <a href="/tag/ssh"><nobr>ssh</nobr></a>

  
  
  <a href="/tag/linux"><nobr>linux</nobr></a>

  
  
  <a href="/tag/device-drivers"><nobr>device-drivers</nobr></a>


        
        
        
      </header>
      <section>

      
<div class="post">

  <h1 class="post-title">Cross Compiling for BeagleBoard targets, and benchmarks</h1>
  Published on <span class="post-date">30 Jun 2022</span>, under: 
  <span class="post-tags">
    &nbsp;|
    
      
      <a class="no-underline" href="/tag/programming"><nobr> programming |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/c"><nobr> c |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/cpp"><nobr> cpp |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/embedded"><nobr> embedded |</nobr>&nbsp;</a>    
    
    &nbsp;
  </span>
  <p></p>
  <p>I have been using a BeagleBoard-xM as a target for the recepies in the book Embedded Programming with Modern C++ Cookbook, and here are a few of the interesting things I’ve come across:</p>

<ul>
  <li>
    <h2 id="cross-compiler">Cross Compiler</h2>
    <p>The book uses a Raspberry Pi emulator on QEMU as a target, and uses the gcc/g++ arm cross compiler (arm-linux-gnueabi-gcc/g++) to build the binaries. As the RPi and BeagleBoard both run arm processors, I assumed that a binary that runs on Raspberry Pi would work on BeagleBoard as well. Spoiler alert: a binary compiled to run on an RPi, will not run on BeagleBoard. Google-fu helped me understand that the BeagleBoard needs a slightly different cross-compiler: arm-linux-gnueabi<strong>hf</strong>-gcc/g++. Once I changed the Cmake file accordingly, I could run the program on BeagleBoard.</p>
  </li>
  <li>
    <h2 id="uninitialized-pointers">Uninitialized Pointers</h2>
    <p>A small program that would create a shared memory region and then have two processes read from, and write to it, gave me unexpected results (and sometimes hit segmentation faults on the last read) on the beagleboard and RPi, whereas on the build system it crashed immediately. It turned out that I was derefencing an uninitialized pointer. On the build system the offending pointer was set to 0x0, but on the bbxm and raspberry pi, it was set to a random pointer. I’m not sure if this is something to do with the architecture or the compiler.</p>
  </li>
  <li>
    <h2 id="system-timer">System Timer</h2>
    <p>One of the exercises involved writing a program to read the system timer on the rpi. This was a little bit of a challenge to port to the BBxM as the beagleboard’s system timer was structured a little differently. I wrote about this in more detail <a href="https://arunvijayshankar.github.io/archive/reading-sync-timer-beagleboard-xm/">here</a></p>
  </li>
  <li>
    <h2 id="benchmarks">Benchmarks</h2>
    <p>Finally I ran lmbench on the build system, an x86_64 machine running ubuntu, and on the beagleboard, which is armv7 running debian:</p>
  </li>
</ul>

<p>BeagleBoard-xM benchmarks</p>

<p><img src="/assets/images/post7/bbxm_bench.png" alt="BeagleBoard-xM Benchmarks" /></p>

<p>Build system benchmarks</p>

<p><img src="/assets/images/post7/x86_bench.png" alt="Build system (x86_64) Benchmarks" /></p>

</div>

      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

      
        <!DOCTYPE html>
<html lang="en-US">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KLNXCRJB2P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KLNXCRJB2P');
</script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Reading the System Timer on Beagleboard XM - Arktos kai Mennos</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Reading the System Timer on Beagleboard XM | Arktos kai Mennos</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Reading the System Timer on Beagleboard XM" />
<meta name="author" content="Arun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="One of the exercises in the book ‘Embedded Programming with Modern C++ Cookbook’ is to read the System Timer on a RaspberryPi. The system timer peripheral on a raspberry pi provides a 64 bit free running counter that increments with every clock tick. Although the book uses QEMU to run a rPi emulator as the target for the programs, I have been using a Beagleboard XM as the target. So far, there have been some changes, but no significant differences in code for the raspberry pi vs the beagleboard. I assumed that reading the system timer would be no different. This was of course, not the case. For a beginner like myself, it was quite challenging to get it working on the bbxm." />
<meta property="og:description" content="One of the exercises in the book ‘Embedded Programming with Modern C++ Cookbook’ is to read the System Timer on a RaspberryPi. The system timer peripheral on a raspberry pi provides a 64 bit free running counter that increments with every clock tick. Although the book uses QEMU to run a rPi emulator as the target for the programs, I have been using a Beagleboard XM as the target. So far, there have been some changes, but no significant differences in code for the raspberry pi vs the beagleboard. I assumed that reading the system timer would be no different. This was of course, not the case. For a beginner like myself, it was quite challenging to get it working on the bbxm." />
<link rel="canonical" href="http://localhost:4000/archive/reading-sync-timer-beagleboard-xm/" />
<meta property="og:url" content="http://localhost:4000/archive/reading-sync-timer-beagleboard-xm/" />
<meta property="og:site_name" content="Arktos kai Mennos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-10T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Reading the System Timer on Beagleboard XM" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arun"},"dateModified":"2022-06-10T00:00:00-07:00","datePublished":"2022-06-10T00:00:00-07:00","description":"One of the exercises in the book ‘Embedded Programming with Modern C++ Cookbook’ is to read the System Timer on a RaspberryPi. The system timer peripheral on a raspberry pi provides a 64 bit free running counter that increments with every clock tick. Although the book uses QEMU to run a rPi emulator as the target for the programs, I have been using a Beagleboard XM as the target. So far, there have been some changes, but no significant differences in code for the raspberry pi vs the beagleboard. I assumed that reading the system timer would be no different. This was of course, not the case. For a beginner like myself, it was quite challenging to get it working on the bbxm.","headline":"Reading the System Timer on Beagleboard XM","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archive/reading-sync-timer-beagleboard-xm/"},"url":"http://localhost:4000/archive/reading-sync-timer-beagleboard-xm/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=e175cf2cc7de7cf31d60056b73775779ae8b25c7">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Arktos kai Mennos</a></h1>
        <nav>
          <ul class="nav-links">
          <li><a href="/" >Home</a></li>  | <li><a href="/about" >About</a></li> | <li><a href="/archive" >Archive</a></li>  | <li><a href="/contact" >Contact</a></li>
          </ul>
        </nav>
        

        <p>Arun Vijayshankar's blog</p>

        
        <p class="view"><a href="https://github.com/arunvijayshankar/arunvijayshankar.github.io">View the Project on GitHub <small>arunvijayshankar/arunvijayshankar.github.io</small></a></p>
        

        

        <h2>Tags</h2>



  
  
  <a href="/tag/programming"><nobr>programming</nobr></a>

  
  
  <a href="/tag/networking"><nobr>networking</nobr></a>

  
  
  <a href="/tag/rust"><nobr>rust</nobr></a>

  
  
  <a href="/tag/python"><nobr>python</nobr></a>

  
  
  <a href="/tag/embedded"><nobr>embedded</nobr></a>

  
  
  <a href="/tag/cpp"><nobr>cpp</nobr></a>

  
  
  <a href="/tag/c"><nobr>c</nobr></a>

  
  
  <a href="/tag/vpn"><nobr>vpn</nobr></a>

  
  
  <a href="/tag/ssh"><nobr>ssh</nobr></a>

  
  
  <a href="/tag/linux"><nobr>linux</nobr></a>

  
  
  <a href="/tag/device-drivers"><nobr>device-drivers</nobr></a>


        
        
        
      </header>
      <section>

      
<div class="post">

  <h1 class="post-title">Reading the System Timer on Beagleboard XM</h1>
  Published on <span class="post-date">10 Jun 2022</span>, under: 
  <span class="post-tags">
    &nbsp;|
    
      
      <a class="no-underline" href="/tag/programming"><nobr> programming |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/cpp"><nobr> cpp |</nobr>&nbsp;</a>    
    
      
      <a class="no-underline" href="/tag/embedded"><nobr> embedded |</nobr>&nbsp;</a>    
    
    &nbsp;
  </span>
  <p></p>
  <p>One of the exercises in the book ‘Embedded Programming with Modern C++ Cookbook’ is to read the System Timer on a RaspberryPi. The system timer peripheral on a raspberry pi provides a 64 bit free running counter that increments with every clock tick. Although the book uses QEMU to run a rPi emulator as the target for the programs, I have been using a Beagleboard XM as the target. So far, there have been some changes, but no significant differences in code for the raspberry pi vs the beagleboard. I assumed that reading the system timer would be no different. This was of course, not the case. For a beginner like myself, it was quite challenging to get it working on the bbxm.</p>

<p>The book starts off by hard coding the base address of the rPi system timer, and a struct to store the two 32 bit sections of the timer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constexpr uint32_t kTimerBase = 0x3F003000;

struct SystemTimer {
  uint32_t CS;
  uint32_t counter_lo;
  uint32_t counter_hi;
};
</code></pre></div></div>

<p>The sync timer address is then mapped using mmap as a shared map and cast as a struct pointer to read the value into counter_lo and counter_hi, which are added together to get the actual timer value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int memfd = open("/dev/mem", O_RDWR | O_SYNC);

SystemTimer *timer = (SystemTimer*)mmap(NULL, sizeof(SystemTimer),
PROT_READ|PROT_WRITE, MAP_SHARED,
memfd, kTimerBase);
</code></pre></div></div>

<p>I knew that it was unlikely that the timer base address will be the same on the bbxm, so the first challenge was to find the right address. I looked for the AM37 manual online, and it turns out that Texas Instruments will let you download it if you register an account with them. So now I have a TI developer account. Oh, and the manual. The manual listed the Sync Timer base address of the 32 kHz clock as 0x48320000, and that the register was 32 bits long. I made the changes, and compiled the build. But when I ran it, the program would only print out one value</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System timer: 64
System timer: 64
System timer: 64
System timer: 64
System timer: 64
System timer: 64
</code></pre></div></div>

<p>It looked as if the timer was not updating with every clock tick. My first suspicion was that address was wrong somehow, or that the mapping was not correct. I spent a considerable amount of time trying to get to the bottom of that, all to no avail. The address was as noted in the manual, and there did not seem to be anything wrong with the mapping. So I did the only thing I could think of, and reached out to the good folks on the internet. One person suggested that maybe the timer was not enabled. This seemed like a plausible root cause, so I went back to the manual and started digging to find out how to check if the timer is disabled. I did find the timer controls, but I honestly did not really understand it. But what I did accidentally discover was that even though the base address for the sync timer on the bbxm is 0x48320000, the actual value of the timer is stored at a 0x0010 offset!</p>

<p>So I dutifully changed the address to 0x48320010, re-compiled, and ran it. I hit a Bus Error. What is a bus error now? I asked my browser, which said that it was a hardware error, letting the OS know that CPU cannot access the memory that the process is trying to access. So I was back to some issue with the address. I was convinced that the physical address was correct this time, so maybe there was something wrong with the virtual address? After some more scouring of the internet, I found this <a href="https://bakhi.github.io/devmem/">post</a>. Reading through it, I finally understood that mmap was creating a new mapping in the virtual address space starting at the physical address we specify in the mmap call. For some reason that I don’t still understand, providing the physical address + the offset to mmap was returning a bad virtual address. But maybe mapping the timer base address first, and then adding the offset might fix it? I tried this, and it worked! The value updated by ~400 units everytime I ran the binary. I also understood why the program was not updating when I ran it with just the base address. The first 4 bytes of the Sync Timer stored just the timer version. I was just reading this constant over and over again. But after first mapping the base physical address and adding the offset, the program read the actual timer value everytime. Here is the entire program (minus error checking):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constexpr uint32_t kTimerBase = 0x48320000;
constexpr uint32_t timer_offset = 0x0010; 


int main() {
    int memfd = open("/dev/mem", O_RDWR | O_SYNC);

    void *map_base = mmap(NULL, sizeof(uint32_t),
    PROT_READ | PROT_WRITE, MAP_SHARED,
    memfd, kTimerBase);

    uint32_t *timer = (uint32_t *)((char *)map_base + timer_offset);

    for (int i = 0; i &lt; 10; i++) {
        std::cout &lt;&lt; "System timer: " &lt;&lt; *timer;
        std::cout &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    return 0;
}
</code></pre></div></div>

<p>As an aside, the program as specified in the book, did not run correctly on the rPi emulator either. But once I made the offset changes above to the code, it read the timer value correctly on every run.</p>

</div>

      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>

      

      <footer>
        
        <p>This project is maintained by <a href="https://github.com/arunvijayshankar">arunvijayshankar</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
